## OSI与TCP/IP

学习计算机网络时，一般采用折中方法，综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnuk4lcc01j312u0kkb24.jpg" alt="WeChatcc1a003c1f1c350d0b483dd82d45c633.png" style="zoom:50%;" />

![WeChatae5f291947fddb9e425f21126587f162.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gorbz8qmzpj30yo0ngkia.jpg)



### 应用层

**应用层(application-layer)的任务是通过应用进程间的交互来完成特定网络应用**。应用层协议定义的是应用进程间的通信和交互规则。对于不同的网络应用需要不同应用层协议。如域名系统**DNS，HTTP**，电子邮件的**SMTP协议**等。我们把应用层交互的数据单元称为**报文**。



### 运输层

**运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。



**运输层主要使用以下两种协议**

1. 传输控制协议**TCP**

   Transmission Control Protocol --  提供**面向连接**的，**可靠**的数据传输服务。

2. 用户数据协议**UDP**

   User Datagram Protocol -- 提供**无连接**的，尽最大努力的数据传输服务。(**不保证数据传输的可靠性**)



**UDP的主要特点**

1. UDP是**无连接**的；

2. UDP使用尽量大努力交付，即**不保证可靠交付**，因此主机**不需要维持复杂的链接状态**；

3. UDP是**面向报文**的；

4. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如**直播，实时视频会议**等)；

5. UDP支持一对一、一对多、多对一和多对多的交互通信。

6. UDP的**首部开销小，只有8个字节**，比**TCP的20个字节**的首部要短。

   

**TCP的主要特点**

1. TCP是**面向连接**的；
2. 每一条TCP连接只能有两个端点，点对点(**一对一**)；
3. TCP提供**可靠**交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
4. TCP提供**全双工**通信，TCP允许通信双方的应用进程在任何时候都能发送数据。TCP两端都设有**发送缓存和接收缓存**，用来临时存放双方通信的数据；
5. **面向字节流**。TCP中的“流”(Stream)指的是流入程序进程或从进程流出的字节序列。面向字节流的含义是：虽然程序应用和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交下来的数据仅仅看成是一连串无结构的字节流。



### 网络层

**网络层(network layer)负责为分组交换网上的不同主机提供通信服务**。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用**IP协议**，因此分组也叫**IP数据报**，简称**数据报**。

**注意： 不要把运输层的"用户数据报UDP"和网络层的"IP数据报"弄混。**

**网络层的另一个任务就是选择(路由选择协议)合适的路由**



### 数据链路层

**数据链路层(data link layer)**通常简称为链路层。**两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要专门的链路层协议**。在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的IP数据报组装成帧**。每一帧包括**数据和必要的控制信息**(如同步信息，地址信息，差错控制等)

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可以从中提出数据，上交给网络层。

控制信息还使接收端能够检测到所收到的帧中有无差错，让如果发现差错，如果发现差错，数据链路层就简单丢弃这个帧。如果需要改正数据在链路层传输时出现的差错，那么要采用可靠性传输协议来纠正出现的差错。



### 物理层

在物理层上所传送的数据单位是**比特**。

**物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异**。



## TCP三次握手和四次挥手

### 三次握手

为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnumxiiu5vj310m0neb29.jpg" alt="WeChatf33c4a9e3e6adc7a01b321a3c0e1a502.png" style="zoom:50%;" />



- 客户端 - 发送带有SYN标志的数据包 - 一次握手 - 服务端
- 服务端 - 发送带有SYN/ACK的数据包 - 二次握手 - 客户端
- 客户端 - 发送带有ACK的数据包 - 三次握手 - 服务端



**为什么要三次握手？**

三次握手的目的是**建立可靠的通信信道**。让双方确认自己与对方的发送与接收是正常的。

- 第一次握手

  Client什么都不能确认；

  Server确认了自己接收正常、对方发送正常；

- 第二次握手

  Client确认了：自己发送、接收正常，对方发送、接收正常。

  Server确认了：自己接收正常，对方发送正常

- 第三次握手

  Client确认了：自己发送、接收正常，对方发送、接收正常。

  Server确认了：自己接收、发送正常，对方接收、发送正常

所以三次握手就能确认双方收发过程是否都正常，缺一不可。

|        |                | 1握手 | 2握手 | 3握手 |
| ------ | -------------- | ----- | ----- | ----- |
| 发送方 | 自己发送正常   |       | T     |       |
|        | 自己接收正常   |       | T     |       |
|        | 接收方发送正常 |       | T     |       |
|        | 接收方接收正常 |       | T     |       |
| 接收方 | 自己发送正常   |       |       | T     |
|        | 自己接收正常   | T     |       |       |
|        | 发送方发送正常 | T     |       |       |
|        | 发送方接收正常 |       |       | T     |







**为什么要传回SYN**

接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。



**传了SYN，为啥还要传ACK**

双方通信无误必须是双方互相发送的信息都无误。**传回SYN，证明发送方到接收方的通道没有问题**，但**接收方到发送方的通道还需要ACK信号来进行验证**。

SYN验证发送方到接收方通道

ACK验证接收方到发送方通道



### 四次挥手

断开一个TCP连接则需要“四次挥手”：

- 客户端 - 发送一个FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个FIN，**确认序号为收到的序号加1**。和SYN一样，一个FIN将占用一个序号
- 服务器-关闭与客户端的连接，发送一个FIN给客户端
- 客户端-发回ACK报文确认，并将**确认序号设置为收到序号加1**



**为什么要四次挥手**

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入**半关闭状态**。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。



举个例子： A和B打电话，通话即将结束后，A说“我没有啥要说的了”，B回答“我知道了”。但B可能还有想要说的话，A不能要求B跟着自己的节奏结束通话，于是B可能又巴拉巴拉说了一通，最后B说“我说完了”，A回答“知道了”，这样通话才算结束。



**为什么要等待2MSL后才断开连接**

**MSL (Maximum Segment Lifetime), "报文最大生存时间"**。确保服务器能收到Client回复的ACK。如果不等待直接断开，第四次挥手AC K丢包了，但客户端已经关闭，此时服务器无法关闭TCP连接。



![2881615201722_.pic_hd.jpg](http://ww1.sinaimg.cn/large/008aPpVGgy1gocphasvnej31b42aogt7.jpg)



## TCP和UDP协议的区别

![WeChat7ae7b65258d303d47074cc604ae5b315.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnvg2qfnouj32o60oie81.jpg)



**UDP**在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。然后UDP**不提供可靠交付**，但在某些情况下UDP确是一种最有效的工作方式(一般用于即时通信)，如：**QQ语音、QQ视频、直播**等。



> UDP首部结构

8个字节

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1god5atrix9j31d00lck8s.jpg" alt="WeChatd8d5899c5e3bf0f726ee02c38e1d4bf7.png" style="zoom:50%;" />



**TCP**提供面向连接的服务。在传送数据之前必须建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要 提供**可靠**的，**面向连接**的运输服务(TCP的可靠体现在TCP在传递数据前，会有**三次握手**来建立连接，而且在数据传递时，有**确认、窗口、重传、拥塞控制**机制，在数据传完后，还会**断开连接**用来节约系统资源)，这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP一般用于**文件传输、发送和接收邮件、远程登录**等场景。



> TCP首部结构

20个字节 (最多可到60字节)

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1god5h35euhj32js13ge81.jpg" alt="WeChat16944245d90ddab342976c547bd8ce43.png" style="zoom:50%;" />



## TCP协议如何保证可靠传输

1. 应用数据被分割成TCP认为最合适发送的数据块。
2. TCP给发送的每一个包编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和**：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
4. TCP的接收端会丢弃重复的数据
5. **流量控制**：TCP连接的每一方都有固定大小的缓冲空间，TCP接收端只允许发送端发送接收端缓冲区能够接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议(**TCP利用滑动窗口实现流量控制**)
6. **拥塞控制**：当网络拥塞时，减少数据的发送。
7. **停止等待协议**：也是为了实现可靠传输的，每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。**超时重传**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。



### 停止等待协议

- 停止等待协议是为了实现可靠传输的，它的基本原理就是**每发完一个分组就停止发送，等待对方确认**。在收到确认后再发下一个分组；
- 在停止等待协议中，若接收方收到**重复分组，就丢弃该分组，但同时还要发送确认**。



1）无差错情况

发送方发送分组，接收方在规定时间内收到，并回复确认。发送方再次发送。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnurojffoyj318i114tjs.jpg" alt="WeChat032b67772d21fa92d202f12b51f558c0.png" style="zoom: 33%;" />

2）出现差错情况(超时重传)

停止等待协议中超时重传指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组。因此每发送完一个分组要设置一个超时计数器，其重传时间应比数据在分组传输的平均往返时间更长一点。这种自动重传方式称为**自动重传ARQ**。另外在停止等待协议中若收到重复分组，就丢弃该分组，同时还要发送确认。**连续ARQ协议**可提高信道利用率。发送端维持一个发送窗口，凡位于窗口内的分组可**连续发送出去，而不需要等待对方确认**。接收方一般采用**累积确认**，按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnurr34cnwj31d40pgk7f.jpg" alt="WeChat81cdabee07a8b5785622eedf14bca970.png" style="zoom:33%;" />



3) 确认丢失和确认迟到

**确认丢失**

当A发送M1消息后，B收到后给A发送了M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后，处理如下：

(1)B丢弃重复的M1消息

(2)B向A发送M1确认消息。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnus2wgv9kj31f00q8h23.jpg" alt="WeChata482883d16f658d542ebf0f6706bff5f.png" style="zoom:33%;" />



**确认迟到**

A发送M1后，B收到并发送确认。在超时时间内没收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息。此时A收到B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息。处理如下：

1. B收到重复的M1后，直接丢弃。
2. A收到重复的确认后，直接丢弃





<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnus1k5l6pj31dm0qm186.jpg" alt="WeChat281ddc23c0f53009fd4844fa3760d523.png" style="zoom:33%;" />

### 自动重传请求ARQ协议

ARQ (Automatic Repeat-reQuest)

停止等待协议中超时重传是指重要超过一段时间仍然没有收到确认，就重传前面发送过的分组。因此每发送完一个分组需要设置一个超时计时器。这种自动重传方式称为自动重传请求ARQ。

优点：简单

缺点：信道利用率低



### 连续ARQ协议

连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以**连续发送**出去，而**不需要等待对方确认**。接收方一般采用**累计确认**，对按序**到达的最后一个分组发送确认**，表明到这个分组为止的所有分组都已经正确收到了。

优点：**信道利用率高**，任意实现，即时确认丢失，也不必重传。

缺点：不能向发送方反映出接收方已经正确收到的所有分组信息。比如：发送方发送了5条消息，中间丢失3号数据包，这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，只好把后三个全部重传一次。这也叫**Go-Back-N(回退N)**，表示需要退回来重传已经发送过的N个消息。



### 滑动窗口

- TCP利用滑动窗口实现流量控制的机制。
- 滑动窗口是一种流量控制技术。早期大家不知道网络拥塞情况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。
- TCP中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大缓冲区可以用来接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况例外，一种是可以发送紧急数据，例如，允许用户终止在远程机上运行的进程。另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。



### 流量控制

- TCP利用滑动窗口实现流量控制
- 流量控制是为了控制发送方发送速率，保证接收方来得及接收。
- 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。



### 拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路避免过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。**拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素**。相反，**流量控制往往是点对点通信量的控制**，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。



为了进行拥塞控制，TCP发送方要维持一个**拥塞窗口(cwnd)**的状态变量。**拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化**。**发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个**。



TCP的拥塞控制有四种算法,即**慢开始、拥塞避免、快重传和快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略(如主动队列管理AQM)，以减少网络拥塞的发生。



#### 慢开始

慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。**cwnd初始值为1，每经过一个传播轮次，cwnd加倍**。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnvdqk6nrej318e0nyqv5.jpg" alt="WeChat9cae140eadc4e9f4d9611ff2954cd194.png" style="zoom:33%;" />





#### 拥塞避免

拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即**每经过一个往返时间RTT就把发送方的cwnd加1**。



#### 快重传与快恢复

在TCP/IP中，**快速重传和恢复 (fast retransmit and recovery，FRR)**是一种拥塞控制算法，它能快速恢复丢失的数据包。**没有FRR，如果数据包丢失了，TCP将会使用定时器来要求传输暂停**。在**暂停的这段时间内，没有新的或复制的数据包被发送**。有了FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果**发送机收到三个重复确认**，它会假定确认件指出的数据段丢失了，并**立即重传这些丢失的数据段**。有了FRR，就不会因为重传时要求的暂停被耽误。而有单独的数据包丢失时，快速重传和恢复(FRR)能最有效地工作。**当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作**。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnvec7pcpdj31ao0soe81.jpg" alt="WeChat391140e7aecd31afcf6f6f5fd22ba3aa.png" style="zoom:33%;" />



## 浏览器中输入URL后主页显示过程

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnvej20aflj31600xeqv5.jpg" alt="WeChat2d1e4fc4b58096563e635405c6ddddb0.png" style="zoom:33%;" />

1. 浏览器查找域名的IP地址

   DNS查找过程：浏览器缓存、路由器缓存、DNS缓存

2. 向浏览器WEB服务器发送一个HTTP请求

   Cookies会随着请求发送给服务器

3. 服务器处理请求

   根据 请求&参数、cookies生成一个HTML响应

4. 服务器返回一个HTML响应

5. 浏览器开始显示HTML

<br>

涉及到的协议：

- DNS

- HTTP

- TCP

- IP

- OPSF  

  路由器选择协议：根据Dijkstra构建路由表

- ARP

  Address Resolution Protocol, IP地址转换成MAC地址（网络层协议）



## 状态码

|      | 类别                            | 原因短语                        |
| ---- | ------------------------------- | ------------------------------- |
| 1XX  | Informational (信息性状态码)    | 接收的请求正在处理              |
| 2XX  | Success (成功状态码)            | 请求正常处理完毕                |
| 3XX  | Redirection (重定向状态码)      | 需要进行附加操作以完成请求      |
| 4XX  | Client Error (客户端错误状态码) | 服务器无法处理请求 (请求错误)   |
| 5XX  | Server Error (服务器错误状态码) | 服务器处理请求出错 (服务器错误) |



## 常见路由协议

> OSPF协议

Open Shortest Path First 开放式最短路径优先

运用了Dijkstra算法

OSPF是基于**链路状态(度量值)**的协议



> RIP协议

Routing Information Protocol 路由信息协议

使用**跳数**(即metric)来衡量到达目标地址的路由距离。





## 各种协议与HTTP协议之间的关系

<img src="https://pic4.zhimg.com/v2-367c03a8065b12a26cccd4437e548eef_r.jpg" alt="WeChat2d1e4fc4b58096563e635405c6ddddb0.png" style="zoom: 50%;" />



## HTTP长连接、短连接

在**HTTP/1.0中默认使用短连接**。客户端和服务器**每进行一次HTTP操作，就会建立一次连接，任务结束就中断连接**。当客户端浏览器访问某个HTML或其他类型的Web页中包含有其他的Web资源(如JavaScript文件、图像文件、CSS文件等)，没遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。



而**从HTTP/1.1起，默认使用长连接，用以保证连接特性**。使用长连接的HTTP协议，会在响应头加入这行代码：

```http
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，**客户端和服务器**之间用于传输HTTP数据的**TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接**。 **Keep-Alive不会永久保持连接，它有一个保持时间**，可以在不同的服务器软件(如Apache)中设定这个时间。实现长连接需要客户端和服务器都支持长连接。



## HTTPS的介绍



**HTTP存在的问题**

- 请求信息明文信息传输，任意被**窃听截取**
- 数据的**完整性未校验**，任意被**篡改**
- 没有验证对方身份，存在**冒充**风险



**什么是HTTPS？**

HTTPS协议 (HyperText Transfer Protocol over Secure Socket Layer)

一般理解为**HTTP+SSL/TLS**, **通过SSL证书来验证服务器的身份**，并为浏览器和服务器之间的通信进行加密。



**什么是SSL？**

SSL (Secure Socket Layer, 安全套接字层)

SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。



TLS (Transport Layer Security, 传输层安全)： 其前身是SSL。



**浏览器在使用HTTPS传输数据的流程是什么？**

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnvfpmvllyj30ua0t6qn5.jpg" alt="WeChat92610bd24ca0e1f8d4b423899ae22618.png" style="zoom: 33%;" />



简言之，**HTTPS用非对称加密实现了对称密钥的沟通与传输**。

1. 首先客户端通过URL访问服务器建立SSL连接。
2. **服务端**接收到客户端请求后，会将网站支持的**证书信息 (证书中包含公钥)** 传送一份**给客户端**。
3. 客户端开始协商SSL连接的安全等级，也就是信息加密的等级
4. **客户端**根据双方同意的安全等级，建立**会话密钥**，然后利用服务端给的**公钥**(证书里面的信息)，**将会话密钥加密**，并传送给网站
5. 网站利用自己的**私钥解密**出会话密钥
6. 服务器利用会话密钥加密与客户端之间的通信。



HTTPS端口 443

HTTP端口  80



## DNS如何做域名解析

www.tmall.com对应的真正域名为www.tmall.com. 。末尾的.称为根域名，一般被省略

根域名的下一级，叫“顶级域名”，比如.com、.net

根下一级叫“次级域名”，如www.tmall.com里面的.tmall,这一级域名是用户可以注册的。

在下一级是主机名www，又称为“三级域名”，用户在自己的域里面为服务器分配的名称。

解析的过程就是**分级查询**

(1) 先在本机的DNS里查，如果有就直接返回

(2)如果本机DNS里没有，就去根服务器查，根服务器发现域名属于com域，因此根域DNS服务器返回它管理的com域中DNS服务器的IP地址。

(3)本机DNS接着向com域的DNS服务器发送查询信息,com域中也没有www.tmall.com这个域名信息，和刚才一样，com域服务器返回它下面tamll.com域的DNS服务器的IP地址。

以此类推，重复后便可以找到目标DNS服务器。



## 常见面试题

### 为什么需要三次握手？不能两次？

|        |                | 1握手 | 2握手 | 3握手 |
| ------ | -------------- | ----- | ----- | ----- |
| 发送方 | 自己发送正常   |       | T     |       |
|        | 自己接收正常   |       | T     |       |
|        | 接收方发送正常 |       | T     |       |
|        | 接收方接收正常 |       | T     |       |
| 接收方 | 自己发送正常   |       |       | T     |
|        | 自己接收正常   | T     |       |       |
|        | 发送方发送正常 | T     |       |       |
|        | 发送方接收正常 |       |       | T     |



### session和cookie

![WeChatb5ff7bd0bb1af1ee3b4131b7ec345a63.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gopmu90xnjj323o18wu0x.jpg)

简单来说，cookie记录了用户是谁，session记录了用户做了什么。

> session

由于HTTP协议是无状态的协议，所以服务器端需要记录用户的状态时，就需要用某种机制来跟踪用户，这个机制就是Session。服务器端保存session的方法有很多，内存、数据库、文件都有。集群的时候要考虑Session的迁移。

> cookie

用cookie标识特定用户。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务器。大多数应用都是通过Cookie来实现Session跟踪的。第一次创建Session的时候，服务器会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个ID发给服务器，就知道你谁了。

> 总结

Session是在服务端保存的一个数据结构，用来跟踪用户的状态，session可以保存在内存、集群、数据库、文件中。

Cookie是客户端保存用户信息的一种机制，用来记录用户的信息。

> Cookie和Session的区别

- 安全性：Session比Cookie安全，Session是存储在服务器端的，Cookie是存储在客户端的。
- 存储值的类型不同：Cookie只支持字符串数据，想要设置其它类型的数据，需要将其转换成字符串，Session可以存任何数据类型。
- 有效期不同：Cookie可设置为长时间保持，比如我们经常使用的默认登陆功能，Session一般失效时间较短，客户端关闭(默认情况下)或者Session超时都会失效。
- 存储大小不同：单个Cookie保存的数据不能超过4K，Session可存储数据远高于Cookie，但是当访问量过多，会占用服务器资源。

### Token

> session认证流程

- 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的Session。
- 请求返回时将此Session的唯一标识信息SessionID返回给浏览器
- 浏览器接收到服务器返回的SessionID信息后，会将此信息存入到Cookie中，同时Cookie记录此SessionID属于哪个域名。
- 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在Cookie信息，如果存在自动将Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID,再根据SessionID查找相应的Session信息，如果没有找到说明用户没有登陆或者登陆失效，如果找到Session证明用户已经登陆可执行后面操作。

从上面流程可知，**SessionID是连接Cookie和Session的一道桥梁**，大部分系统也是根据此原理来验证用户登陆状态。

>  Token介绍

Token可分为Access Token和Refresh Token

- 访问资源接口(API)时所需要的资源凭证
- 简单token的组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，token的前几位以哈希算法压缩成一定长度的十六进制字符串)
- 特点
  - 服务端无状态化、可扩展性好
  - 支持移动端设备
  - 安全
  - 支持跨程序调用

> Access Token身份验证流程

![WeChatf1e2a52785e01b90905ed6a7d517d14e.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gopnxiaxpaj31zo0vgqv5.jpg)

1. 客户端使用用户名跟密码请求登陆。
2. 服务端接收到请求，去验证用户名与密码
3. 验证成功后，服务端会签发一个token并把这个token发送给客户端
4. 客户端接收到token以后，会把它存储起来，比如放在cookie或者localStorage里
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的token
6. 服务端收到请求，然后去验证客户端请求里面带着的token，如果验证成功，就向客户端返回请求的数据。



- 每一次请求都需要携带token，需要把token放到HTTP的Header里
- 基于token的用户认证是一种服务端无状态的认证方式，服务端不用存放token数据。**用解析token的计算时间换取session的存储空间，从而减轻服务器的压力**。

> Refresh Token

refresh token是专门用于刷新access token的token。如果没有access token,也可以刷新access token,但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了refresh token，可以减少这个麻烦，客户端直接用refresh token去更新access token，无需用户进行额外操作。

![WeChat7e8bdab491387dc2bdfcc024e2ff654c.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gopoh3k3xkj31w81ccx6q.jpg)

- Access Token的有效期比较短，当Access Token由于过期失效时，使用Refresh Token就可以获取到新的Token，如果Refresh Token也失效了，用户就只能重新登录了。
- Refresh Token及过期时间是存储在服务器的数据库中，只有在申请新的Access Token时才会验证，不会对业务接口响应时间造成影响，也不需要像Session一样一直保存在内存中以应对大量的请求。

### Session和Token的区别

- Session是一种**记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息**。而Token是**令牌，访问API时所需要的资源凭证。Token使服务端无状态化，不会存储会话信息**。
- Session和Token并不矛盾，作为身份认证Token安全性比Session好，因为每一个请求都有**签名**还能防止监听和重访攻击，而**Session就必须依赖链路层来保障通讯安全**。如果**需要实现有状态会话，仍然可以增加Session来在服务器端保存一些状态**。
- Session认证只是简单的把User信息存储到Session里，因为SessionID的不可预测性，暂且认为是安全的。而token，如果指的是OAuth Token或类似的机制的话，提供的是认证和授权，认证是针对用户，授权是针对APP。其目的是让某APP有权利访问某用户的信息。这里的Token是唯一的，不可以转移到其它App上，也不可以转移到其它用户上。Session只提供一种简单的认证，即只要有此SessionID，即认为有此User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。简单来说：**如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用Token。如果永远只是自己的网站，自己的App，用什么都无所谓**。

