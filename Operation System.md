# 第一章 

## 概念

### 操作系统的特征

**并发性和共享性互为存在条件**

- 并发

  并发：宏观同时发生，微观交替发生。

  并行：多个事件同一时刻同时发生。

- 共享

  - 互斥共享方式 

    一个时间段内只允许一个进程访问该资源

    eg. 使用QQ和微信视频。同一时间下只能分配给一个。

  - 同时共享方式

    允许一个时间段内由多个进程“同时”对它们进行访问

    eg. 使用QQ和微信发文件，宏观上同时发送，两个进程都在访问磁盘资源。微观上，两个进程是交替着访问硬盘的。

- 虚拟

  - 空分复用技术 (如虚拟存储器技术)
  - 时分复用技术 (如虚拟处理器)

- 异步



### OS发展历史

**手工操作阶段**



**批处理阶段**

单道批处理

缺点：资源利用率低



多道批处理 (并发、共享)

类似流水线

![WeChat2b66bf3f9b5c1c3ff87d6c1479f662a3.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnhgzx36wmj31c810ke81.jpg)



主要缺点： 用户相应时间长，没有人机交互



**分时操作系统**

计算机以时间片为单位轮流为各个用户/作业服务。

主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。

缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的。



**实时操作系统**

优点：优先响应一些紧急任务，某些紧急任务不需时间片排队。



在实时操作系统下，计算机接收到外部信号后及时进行处理，并且要在严格时限内处理完事件。 实时操作系统的主要特点是及时性和可靠性。

- 硬实时系统

  必须在绝对严格的规定时间内完成处理

- 软实时系统

  能接受偶尔违反时间规定



### OS的运行机制和体系结构

#### 运行机制

**两种指令**

指令：处理器(CPU)能识别、执行的最基本命令

- 特权指令

  如内存清零指令（不允许用户线程使用）

- 非特权指令

  如普通的运算指令



CPU如何判断当前是否可以执行特权指令？

**两种处理器状态**

- 用户态（目态）

  只能执行非特权指令

- 核心态（管态）

  能执行特权指令和非特权指令



**两种程序**

- 内核程序

  系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。

- 应用程序

  只能执行非特权指令，运行在用户态



![WeChat3514c2c2ec0e7d9a6a9130ec744d4366.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnhhmr82ttj31ts0nkb29.jpg)

内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。

实现操作系统内核功能的程序就是内核程序。



#### **操作系统内核**

时钟管理，中断处理，原语  是与硬件关联较密切的模块  

- 时钟管理

  实现计时功能。

- 中断处理

  负责实现中断机制

- 原语

  - 是一种特殊的程序
  - 处于操作系统最底层，是最接近硬件的部分
  - 这种查询运行具有原子性，不能被中断
  - 运行时间较短、调用频繁

- 对系统资源进行管理的功能(有些操作系统不把这部分归为“内核功能”)

  - 进程管理
  - 存储器管理
  - 设备管理





#### **操作系统体系结构**

- 大内核
  - 将操作系统的主要功能模块都作为系统内核，运行在核心态
  - 优点：高性能
  - 缺点：内核代码庞大，结构混乱，难以维护
- 微内核
  - 只把最基本的功能保留在内核
  - 优点：内核功能少，结构清晰，方便维护
  - 缺点：需要频繁在核心态和用户态之间**切换**，性能低



**大内核和微内核划分方式**

![WeChat1149c4e9e688a6c90f19dd5a02c2e45a.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnhhvn1no4j31r40wcb29.jpg)

------

### 中断和异常

#### 中断的概念和作用

1. 当中断发生时，CPU立即进入核心态
2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理。
3. 对于不同的中断信号，会进行不同的处理。



中断可以使CPU从**用户态切换为核心态**，使操作系统获得计算机的控制权。



问题：用户态、核心态之间的切换是怎么实现的？

答：“用户态 -> 核心态” 通过中断实现。并且**中断**是**唯一途径**。

“核心态 -> 用户态” 通过执行一个**特权指令**，将程序状态字(PSW)的标志位设置为"用户态“。



#### 中断的分类

- 内中断 (也称为异常、例外、陷入)

  信号来源： CPU**内部**， 与当前执行指令有关

  - 自愿中断——指令中断

    如：系统调用时使用的访管指令(又叫陷入指令，trap指令)

  - 强迫中断

    - 硬件故障

      如缺页

    - 软件中断

      如整数除0

- 外中断 (中断)

  信号来源：CPU**外部**，与当前执行的指令无关

  - 外设请求

    如：I/O操作完成发出的中断信号

  - 人工干预

    如：用户强行终止一个进程



#### 外中断的处理过程

Step1: 执行完每个指令之后，CPU都要检查当前是否有外部中断信号。

Step2: 如果检测到外部中断信号，则需要保护被中断进程的CPU环境(如程序状态字PSW、程序计数器PC、各种通用寄存器)

Step3:根据中断信号类型转入相应的中断处理程序(此程序运行在核心态)

Step4:恢复原进程的CPU环境并退出中断，返回原进程继续往下执行。



------

### 系统调用

操作系统需要向上提供一些服务。主要包括**命令接口**和**程序接口**。其中，程序接口由一组**系统调用**组成。

应用程序通过**系统调用**请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的**稳定性和安全性**，防止用户进行非法操作。



#### 系统调用与库函数的区别

![WeChat174ba982f7c990ddb1f98f1955898331.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gni4zdiqusj31ju0m0hdt.jpg)



#### 系统调用背后过程

传递系统调用参数->执行陷入指令(用户态)->执行系统调用(核心态)->返回用户程序

本处陷入指令类似于汇编 int x 指令，int是interrupt的意思，x是系统调用对于操作的编号

注意：

1. **陷入指令**是在**用户态**执行的，执行完后立即引发一个**内中断**，从而CPU进入**核心态**。

2. 发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。
3. 陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。



# 第二章 

## 进程

系统为每个运行的程序配置一个数据结构，成为进程控制块(PCB),用来描述进程的各种信息。



### 进程的组成

**PCB、程序段、数据段**三部分构成了**进程实体**(进程映像)，一般情况下，我们把进程实体简称为进程，所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB。

注意：**PCB是进程存在的唯一标志**。



PCB：PCB包含操作系统对进程进行管理所需的各种信息。

程序段：程序代码

数据段：程序运行时产生的运算数据。如全局变量、局部变量。

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnikr63n4cj30e40ua7js.jpg" alt="WeChat9cc089557c4b3423303143f924e5d591.png" style="zoom: 33%;" />

**PCB结构**

- 进程描述信息

  - 进程标识符PID
  - 用户标识符UID

- 进程控制和管理信息

  - 进程当前状态
  - 进程优先级

- 资源分配清单

  - 程序段指针
  - 数据段指针
  - 键盘
  - 鼠标

- 处理机相关信息

  - 各种寄存器值

    进程切换时需要把当前运行情况记录下来保存在PCB中，如程序计数器的值表示当前程序执行到哪一句。保留中断发生时的状态。



进程是进程实体的**运行过程**，是系统进行**资源分配**和**调度**的一个独立单位。

------



### 进程的组织



**进程组织方式**

- 链接方式
  - 按照进程状态将PCB分为多个队列
  - 操作系统持有指向各个队列的指针
- 索引方式
  - 根据进程状态的不同，建立几张索引表
  - 操作系统持有指向各个索引表的指针



**链接方式**

![WeChatff01b87f8fa14fff3fb4332216df61b9.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnilbp6qcwj32du19ee83.jpg)



**索引方式**

![WeChat44f05f7783d77b14e4eb56ce751f247d.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnildksifjj31wm16yhdt.jpg)



------



### 进程的特性

- 动态性 (**最基本的特征**)

  进程是程序的一次执行过程，是动态地产生、变化和消亡的

- 并发性

  内存中有多个进程实体，各进程可并发执行

- 独立性

  进程是能够独立运行、独立**获得资源、独立接受调度的基本单位**

- 异步性

  各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题

- 结构性

  每个进程都会配置一个PCB。结构上看，进程由**程序段、数据段、PCB**组成



------

### 进程的状态及转换

**三种基本状态**

- 运行态(Running)  

  CPU ☑️   其它所需资源☑️

  占有CPU，并在CPU上运行

- 就绪态(Ready)

  CPU ❌   其它所需资源☑️

  具备运行条件，没有空闲CPU，而暂时不能运行

- 阻塞态(Waiting/Blocked,又称：等待态)

  CPU ❌   其它所需资源❌

  因为等待某一事件而暂时不能运行

  如等待操作系统分配打印机、等待读磁盘操作的结果。

**另外两种状态**

- 创建态(New,又称：新建态)

  进程正在被创建，操作系统为进程分配资源、初始化PCB

- 终止态(Terminated, 又称：结束态)

  进程正在从系统中撤销，操作系统回收进程拥有的资源、撤销PCB



**进程的转换**

![WeChatfa60b05e161d205ba6134e88342b33ed.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnim9vmd9ij31gm0qe7wi.jpg)



- 就绪态 -> 运行态

  进程被调度

- 运行态 -> 就绪态

  时间片到，或CPU被其它高优先级的进程抢占

- 运行态 -> 阻塞态

  等待系统资源分配，或者某事件发生(主动行为)

- 阻塞态 -> 就绪态

  资源分配到位，等待的时间发生(被动行为)

  

注意： 不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态 。

------

### 进程控制

进程控制就是实现进程状态转换。

用原语实现进程控制。原语的特点是执行期间**不允许中断**，具有**原子操作**。

原语的原子操作特性通过**关/开中断**来实现

原语时一种特殊的程序

#### 进程的创建

- 创建原语

  - 申请空白PCB
  - 为新进程分配所需资源
  - 初始化PCB
  - 将PCB插入就绪队列

- 引起进程创建事件

  - 用户登陆

    分时系统中，用户登陆成功，系统会为其建立一个新的进程

  - 作业调度

    多道批处理系统中，有新的作业放入内存时，会为其创建一个新的进程

  - 提供服务

    用户向操作系统提出某些请求时，会新建一个进程处理该请求

  - 应用请求

    由用户进程主动请求创建一个子进程



#### 进程的终止

-  撤销原语
  - 从PCB集合中找到终止进程的PCB
  - 若进程正在运行，立即剥夺CPU，将CPU分配给其它进程
  - 终止其所有子进程
  - 将该进程拥有的所有资源归还给父进程或操作系统
  - 删除PCB
- 引起进程终止的事件
  - 正常结束
  - 异常结束
  - 外界干预



#### 进程的阻塞

- 阻塞原语
  - 找到要阻塞的进程对应的PCB
  - 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行
  - 将PCB插入相应事件的等待队列
- 引起进程阻塞的事件
  - 需要等待系统分配某种资源
  - 需要等待互相合作的其它进程完成工作



#### 进程的唤醒

- 唤醒原语
  - 在事件等待队列中找到PCB
  - 将PCB从等待队列移除，设置进程为就绪态
  - 将PCB插入就绪队列，等待被调度
- 引起进程唤醒的事件
  - 等待的事件发生



#### 进程的切换

- 切换原语
  - 将运行环境信息存入PCB
  - PCB移入相应队列
  - 选择另一个进程执行，并更新其PCB
  - 根据PCB恢复新进程所需的运行环境
- 引起进程切换的事件
  - 当前进程时间片到
  - 有更高优先级的进程到达
  - 当前进程主动阻塞
  - 当前进程终止



------

### 进程通信

各进程拥有的内存地址空间**相互独立**。

为了保证安全，一个进程**不能直接访问**另一个进程的地址空间。

必须通过操作系统提供的方法进行通信



**进程通信**

- 共享存储
- 消息传递
- 管道通信



#### 共享存储

![WeChat25190c0ee4677886075dd4b53d7d5e8f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gniot2j49dj311q0js7eu.jpg)

两个进程对共享空间的**访问**必须是**互斥**的(互斥访问通过操作系统提供的同步实现)

操作系统只负责提供共享空间和同步互斥工具(如P、V操作)



- 基于数据结构的共享

  比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种**低级通信**方式。

- 基于存储区的共享

  在内存中划出一块共享储存区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种**高级通信**方式。



#### 管道通信

![WeChatc0a5d4de8652a44c1d3263baa80bd1db.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnip0j9yx6j319s04qjxr.jpg)

“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。



1. 管道只能采用**半双工通信**，某一时间段内只能实现单向的传输。如果要实现**双向同时通信，则需要设置两个管道**。
2. 各进程需要**互斥**地访问管道。
3. 数据以字节流的形式写入管道，当**管道写满**时，**写进程**的write()系统调用将被**阻塞**，等待读进程将数据取走。当读进程将数据全部取走后，**管道变空**，此时**读进程**的read()系统调用将**被阻塞**。
4. 如果**没写满，就不允许读**。如果**没读空，就不允许写**。
5. 数据一旦被读出，就从管道中被抛弃，这意味着**读进程最多只能有一个**，否则可能会有读错数据的情况。



#### 消息传递

进程间的数据交换以**格式化的消息**(Message)为单位。进程通过操作系统提供的"发生消息/接收消息"两个**原语**进行数据交换。

![WeChat08f2e160ee3ff0e4ee83e7174f8ea6e7.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnipcufafjj30ra09eh0g.jpg)



- 直接通信方式

  消息直接挂在接收进程的消息缓冲队列上

  <img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnipfzmk9tj30k00d0aib.jpg" alt="WeChatf21f6deea963a261e089694852bbe961.png" style="zoom: 50%;" />

- 间接通信方式

  消息要先发送到中间实体中

  <img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnipictqr4j30rq094guq.jpg" alt="WeChat0b0f401850d9f3282bdeedd8a147b5d6.png" style="zoom: 50%;" />



------

### 线程

线程是一个**基本的CPU执行单元**，也是**程序执行流的最小单位**。

引入线程后，进程只作为**除CPU之外**的系统资源分配单元(打印机、内存地址空间等都是分配给进程的)。



#### 带来的变化

- 资源分配、调度
  - 传统进程机制中，进程是资源分配、调度的基本单位
  - 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
- 并发性
  - 传统进程机制中，只能进程间并发
  - 引入线程后，各线程间也能并发，提升了并发度
- 系统开销
  - 传统的进程间并发，需要切换进程的运行环境，系统开销很大
  - 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
  - 引入线程后，并发所带来的系统开销减小



#### 线程的属性

- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块(TCB)
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程的线程，系统开销很小
- 切换进程，系统开销很大



#### 线程的实现方式



- 用户级线程(User-Level Thread, ULT)

  用户线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责(包括线程切换)

  用户级线程中，线程切换可以在用户态下完成，无需操作系统干预。

  用户线程对用户不透明，对操作系统透明。

  ![WeChatd6dd2edb38ff6bf7c730724c8efa0dde.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqdv2c8dj30m20jmn76.jpg)

  

- 内核级线程(Kernel-Level Thread，KLT，又称"内核支持的线程")

  <img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqkztdn0j30ls0kodtb.jpg" alt="WeChatd4cb7c837b738f4978957a0d2a33cc9e.png" style="zoom:50%;" />

  内核级线程的**管理工作**由操作**系统内核**完成。线程调度、切换等工作都由内核负责，因此**内核级线程的切换**必须在**核心态**下才能完成。

  内核级线程是只有操作系统才能看到的线程。



在支持用户级线程和内核级的系统中，可以采用二者组合的方式：将n个用户级线程映射到m个内核级线程上(n>=m)

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqoegeraj30mq0lctnz.jpg" alt="WeChatcb6f7215e787ac34c73131d211c048ba.png" style="zoom:50%;" />

**重点**

操作系统只“看得见”内核级线程，因此只有**内核级线程才是处理机分配的单位**。



#### 多线程模型



##### 多对一模型

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqrql2o8j30mi0lc14x.jpg" alt="WeChat6c8d489393ec470ce7f546300260404e.png" style="zoom:50%;" />

多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被组设，并发度不高。多个线程**不可**在多核处理机上**并行**运行。



##### 一对一模型

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gniqw0herwj30o20le16s.jpg" alt="WeChat50c878add5cd1263d8cb814de119e5ac.png" style="zoom:50%;" />

一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

缺点：一个用户进程占用多个内核级进程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。



##### 多对多模型

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnir0cae7qj30mm0lik7l.jpg" alt="WeChat2760e4681983ecdb5d4ad1d55262f473.png" style="zoom:50%;" />

n用户及线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程。

优点：克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。



------

## 调度



**处理机调度**从就绪队列中按照一定的**算法**选择一个进程并**将处理机分配给它**运行。



### 调度的三个层次

#### 高级调度

高级调度(作业调度)。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并**建立相应的进程(建立PCB)**，使它**获得竞争处理机的权利**。

高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。**作业调入时会建立相应的PCB，作业调出时才撤销PCB**。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。



#### 中级调度

引入虚拟存储技术之后，可将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是**提高内存利用率**和**系统吞吐量**。

暂时调到外存等待的进程状态为**挂起**状态。**PCB**并不会一起调到外存，而是会**常驻内存**。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到**挂起队列**中。



**中级调度**(内存调度),决定将哪个处于挂起状态的进程重新调入内存。

一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。



补充知识：**进程的挂起态与七状态模型**

暂时调到外存等待的进程状态为**挂起状态**(挂起态,suspend)

挂起态又可以进一步细分为**就绪挂起、阻塞挂起**两种状态

![WeChat66d8be1617f3e4a9a840e5c55b116c7b.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnit5ejyb1j32l410cu0y.jpg)

挂起和阻塞的区别，两种状态都是暂时不能获取CPU的服务，但挂起态是将进程映像调到外存区，而阻塞态下进程映像还在内存中。



#### 低级调度

**低级调度(进程调度)**，主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中**最基本的一种调度**。

进程调度的**频率很高**，一般几十毫秒一次。



#### 三个调度的联系、对比

|                    | 做什么                                                       | 调度发生在           | 发生频率 | 对进程状态的影响                  |
| ------------------ | ------------------------------------------------------------ | -------------------- | -------- | --------------------------------- |
| 高级调度(作业调度) | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存->内存(面向作业) | 最低     | 无->创建态->就绪态                |
| 中级调度(内存调度) | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存     | 外存->内存(面向进程) | 中等     | 挂起态->就绪态 (阻塞挂起->阻塞态) |
| 低级调度(进程调度) | 按照某种规则，从就绪队列中选择一个进程为其分配处理机         | 内存->CPU            | 最高     | 就绪态->运行态                    |

------

### 进程调度时机、切换与过程、方式



#### 时机

什么时候需要进行进程调度与切换？

- 当前运行的进程**主动放弃**处理机
  - 进程正常终止
  - 运行过程中发生异常而终止
  - 进程主动请求阻塞(如 等待I/O)
- 当前运行的进程**被动放弃**处理机
  - 分给进程的时间片用完
  - 有更紧急的事需要处理(如I/O中断)
  - 有更高优先级的进程进入就绪队列

什么时候不能进行进程调度与切换

- 在**处理中断的过程中**。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
- 进程在**操作系统内核程序临界区**中
- 在**原子操作过程中**(原语)。原子操作不可中断。



临界资源：一个时间段只允许一个进程使用的资源。

临界区：访问临界资源的那段代码。

内核程序临界区一般是用来访问**某种内核数据结构**的，比如进程的就绪队列(又各就绪进程的PCB组成)



内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。

普通临界区访问临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。



#### 方式

**非剥夺调度方式**

非剥夺调度方式，又称**非抢占方式**。只允许进程主动放弃处理机。在运行过程中即使有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

**剥夺调度方式**

剥夺调度方式，又称**抢占方式**。当一个进程正在处理机上执行时，如果有一个更重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给哪个更紧迫的进程。



#### 切换与过程

“狭义的进程调度“与”进程切换的区别“：

**狭义的进程调度**指的是从就绪队列中**选中一个要运行的进程**。(这个进程可以是刚刚被暂停执行的进程，也可能是**另一个进程**，后一种情况就需要**进程切换**)

**进程切换**是指一个进程让出处理机，由另一个进程占用处理机的过程。

**广义的进程调度**包含了选择一个进程和进程切换两个步骤。



进程的切换过程主要完成了：

1. 对原来运行进程各种数据的保存

2. 对新的进程各种数据的恢复

   (如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)

注意：**进程切换是由代价的**，因此如果过于频繁的进行进程调度、切换，会使整个系统的效率降低。



------

### 调度算法的评价指标

- CPU利用率

  利用率=忙碌时间/总时间

- 系统吞吐量

  单位时间内完成的作业数量

- 周转时间

  从作业被提交给系统，到作业完成的时间间隔

  - 周转时间、平均周转时间

  - 带权周转时间、平均带权周转时间

    带权周转时间 = 作业周转时间/作业实际运行时间

- 等待时间

  等待被服务的时间之和

- 响应时间

  从提交请求到首次产生响应所用的时间。

------

### 调度算法

#### 先来先服务(FCFS)

非抢占式算法



优点：公平、算法实现简单

缺点：排在长作业(进程)后面的短作业需要等待很长时间，对短作业来说用户体验不好。



FCFS算法**对长作业有利**，**对短作业不利**。



是否会导致**饥饿**(某进程/作业长期得不到服务) ： 不会



#### 短作业优先(SJF)

非抢占式算法

优点：短作业快速被执行

缺点：不公平

会导致饥饿(长时间得不到服务)、饿死(一直等不到服务)

#### 高响应比优先(HRRN)

响应比 = （等待时间+要求服务器时间）/ 要求服务时间

可以用于作业调度和进程调度

非抢占式算法

优点：综合考虑了等待时间和运行时间

等待时间相同时，要求服务时间短的优先(SJF的优点)

要求服务时间相同时，等待时间长的优先(FCFS优点)

不会导致饥饿

#### 时间片轮转(RR)

**抢占式**算法。 由时钟装置发出**时钟中断**来通知CPU时间片已到。

优点：公平；响应快，适用于分时操作系统；

缺点：由于高频率的进程切换，有一定系统开销；不区分紧急度

不会导致饥饿



#### 优先级调度

可以用于作业调度也可以用于进程调度。

非抢占式和抢占式都有



如何设置优先级

- 系统进程优先级高于用户进程

- 前台进程优先级高于后台进程

- 操作系统更偏好I/O 型进程(称I/O繁忙型进程)

  计算型进程(CPU繁忙型进程)

  I/O设备和CPU可以并行工作。优先让I/O繁忙型进程运行，越可能让I/O设置投入工作，资源利用率、系统吞吐量提升。



动态优先级

- 如果等待了很久，可以提高优先级
- 如果占用处理机很久，可以降低优先级
- 如果频繁I/O，可以提高优先级



优点：优先级区分紧急度，适用于实时操作系统。

缺点：可能导致低优先级作业的饥饿



#### 多级反馈队列调度

unix适用了本算法



结合各种算法优点

用于进程调度

抢占式算法

采用分级、不同时间片

优点：相对公平(FCFS优点); 每个新到达的进程都可以快速响应(RR优点);短进程只用较少时间可以完成(SPF优点);不必实现估计进程的运行时间；

会导致饥饿



## 进程同步、互斥

一个时间段内只允许一个进程使用的资源成为临界资源。临界资源需要互斥。



遵循原则

- 空闲让进

- 忙则等待

- 有限等待

  要在有限时间进入临界区，防止饥饿

- 让权等待

  进入不了临界区的进程，要释放处理机，防止忙等



### 进程互斥的软件实现方法

#### 单标志法

两个进程在**访问完临界区后**会把临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**。

```java
int turn = 0; //表示允许进入临界区的进程号
// P0进程
whlie(turn != 0); 	1
critical section;		2
turn = 1;						3  // 修改成1可以访问
remainder section; 	4  //剩余区
  

// P1进程
whlie(turn != 1); 	1
critical section;		2
turn = 0;						3  // 修改成0可以访问
remainder section; 	4  //剩余区
```

算法缺点， 顺序 P0->P1->P0->P1....

如果一开始标记位为0，P0不访问 P1也访问不了

**违背了“空闲让进”**



#### 双标志先检查法

```java
boolean flag[2];
flag[0] = false;
flag[1] = false; //开始设置两人都不想进

// P0进程
while(flag[1]);			1
flag[0] = true;			2
critical section;		3
flag[0] = false;		4
remainder section;

// P1进程
while(flag[0]);			5
flag[1] = true;			6
critical section;		7
flag[1] = false;		8
remainder section;
```

若按152637执行，P0和P1将同时访问临界区

**违背了“忙则等待”原则**。



#### 双标志后检查法

```java
boolean flag[2];
flag[0] = false;
flag[1] = false; //开始设置两人都不想进

// P0进程
flag[0] = true;			1
while(flag[1]);			2
critical section;		3
flag[0] = false;		4
remainder section;

// P1进程
flag[1] = true;			5
while(flag[0]);			6
critical section;		7
flag[1] = false;		8
remainder section;
```

按照1526的顺序执行，P0和P1都将无法进入临界区。

解决了“**忙着等待**”

违背了**“空闲让进”和“有限等待**”

各进程长期无法访问临界资源。



#### Peterson算法

孔融让梨

```java
boolean flag[2];
flag[0] = false;
flag[1] = false; //开始设置两人都不想进

int turn = 0; // turn 表示优先让哪个进入临界区

// P0进程
flag[0] = true;						1
turn = 1;									2
while(flag[1]&&turn==1);	3
critical section;					4
flag[0] = false;					5
remainder section;

// P1进程
flag[1] = true;						6
turn = 0;									7
while(flag[0]&&turn==0);	8
critical section;					9
flag[1] = false;					10
remainder section;
```

Peterson 算法违背了“让权等待”原则，会发生忙等。



### 进程互斥的硬件实现方法



#### 中断屏蔽方法

利用"开/关中断指令"实现(在某进程开始访问临界区到结束访问为止不允许被中断，也就不能发生进程切换，因此不可能发生两个同时访问临界区的情况)

```
关中断;
临界区;
开中断;
```

优点：简单、高效

缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态)



#### TestAndSet 指令

简称TS或TSL指令，TSL指令是**用硬件实现的**，执行的过程不允许被中断。S

```c
bool TestAndSet (bool *lock){
  bool old = *lock;
  *lock = true;
  return old;
}

while(TestAndSet(&lock)); // 上锁并检查
临界区代码段...
lock = false;   //"解锁"
剩余区代码段...
```

TSL指令把“检查”和“上锁”操作用硬件方式变成了原子操作。

优点：实现简单；适用于多处理机环境

缺点：不满足“让权等待”原则，忙等。



#### Swap指令

也称Exchange指令，或XCHG指令。

Swap指令是用硬件实现的，执行过程不允许被中断

```c
bool old = true;
while(old==true)
  	swap(&lock,&old);
临界区代码段...
lock = false;
剩余区代码段...
```

不满足“让权等待”



### 信号量机制

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而方便的实现进程互斥、进程同步。

一对原语：**wait(S)**原语和**signal(S)**原语，简称为**P、V操作**。



#### 整型信号量

用一个整数型的变量作为信号量，用来表示**系统中某种资源的数量**。对信号量的操作只有三种，**初始化、P操作、V操作**。

整型信号量不满足“让权等待”，会发生忙等。

```java
int S = 1;
void wait(int S){ // wait原语
  while(S<=0);  // 忙等
  S=S-1;  		// 占用一个资源
}
void signal(int S){ //signal原语
  S=S+1; 			// 释放一个资源
}

// 进程P0
wait(S);			// 进入区， 申请资源
使用打印机;  	// 临界区 访问资源
signal(S);		// 退出区 释放资源
```

#### 记录型信号量

```c
typedef struct{
  int value;					//剩余资源数
  struct process *L;  // 等待队列
} semaphore;

void wait(semaphore S){
  S.value--;
  if(S.value<0){
    // block原语使进程从运行态进入阻塞态
    block (S.L);
  }
}

void signal(semaphore S){
  S.value++;
  if(S.value<=0){
    //wakeup原语唤醒等待队列中的一个进程，从阻塞态变为就绪态
    wakeup(S.L);
  }
}
```

**遵循“让权等待”**



### 信号量机制应用

#### 实现进程互斥

1. 分析并发过程的关键活动，划定临界区
2. 设置互斥信号量mutex，**初值为1**
3. 进入临界区之前执行P(mutex)
4. 在临界区之后执行V(mutex)

```c
semaphore mutex = 1;
P1(){
  P(mutex);
  临界代码段;
  V(mutex);
}
P2(){
  P(mutex);
  临界代码段;
  V(mutex);
}
```



#### 实现进程同步

1. 分析什么地方需要实现“同步关系”。
2. 设置同步信号量S，**初始值为0**
3. 在"前操作"之后执行V(S)
4. 在“后操作”之前执行P(S)

```java
semaphore S = 0;
P1(){
  代码1;
  代码2;
  V(S);
  代码3;
}
P2(){
  P(S);
  代码4;
  代码5;
  代码6;
}
// 4必须在1，2后才能执行
```



#### 实现进程的前驱关系

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnj4g4uchjj30ki0mgk2j.jpg" alt="WeChateb701e033ab20321a64b241e84b747d9.png" style="zoom:50%;" />

1. 为每一对前驱关系各设置一个同步变量
2. 在"前操作"之后对应的同步变量执行V(S)
3. 在“后操作”之前对应的同步变量执行P(S)

```c
P1(){
  S1;
  V(a);
  V(b);
}
P2(){
  P(a);
  S2;
  V(c);
  V(d);
}
P3(){
  P(b);
  S3;
  V(g);
}
P4(){
  P(c);
  S4;
  V(e);
}
P5(){
  P(d);
  S5;
  V(f);
}
P6(){
  P(e);
  P(f);
  P(g);
  S6;
}
```

### 生产者消费者问题

![WeChat095566ca1ba979b92e8dc8795dd71237.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnj4qbj4idj31ci0gg7kf.jpg)

缓冲区是临界资源，各进程必须**互斥**地访问。

缓冲区满时，生产者要等待消费者取走商品(**同步**)

缓冲区空时，消费者要等待生产者生产商品(**同步**)



```c
// 互斥信号量，实现缓冲区的互斥访问
semaphore mutex = 1;
// 同步信号量，表示空闲缓冲区的数量
semaphore empty = N;
// 同步信号量，表示产品的数量，也即非空缓冲区的数量。
semaphore full = 0;

producer(){
  生产一个产品;
  P(empty);
  P(mutex);
  把产品放入缓冲区;
  V(mutex);
  V(full);
}

consumer(){
  P(full);
  P(mutex);
  从缓冲区取走产品;
  V(mutex);
  V(empty);
  使用产品;
}

```

![WeChata0d8405bdd2add951832b71eee8d8c1b.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnj5qweo7hj30vw0ban8u.jpg)



**先同步，后互斥**。如果相反，可能造成死锁。

![WeChat5100a89ad65ab7e9f13be68bd87e42cf.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnj5jx10cwj31e60t84qq.jpg)



### 多生产者多消费者

![WeChate1cbea927a89b4071d0327188dcc3879.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnj6ags4kcj31k20qk7wi.jpg)

![WeChat2e421de04539b298bb2afe07413f62be.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnj6dvd97oj31da0feb29.jpg)

```c
dad(){
  while(1){
    准备一个苹果;
    P(plate);
    P(mutex);
    放入一个苹果;
    V(mutex);
    V(apple);
  }
}
mom(){
  while(1){
    准备一个橙子;
    P(plate);
    P(mutex);
    放入一个橙子;
    V(mutex);
    V(orange);
  }
}
daughter(){
  while(1){
    P(apple);
    P(mutex);
    拿出一个苹果;
    V(mutex);
    V(plate);
    吃苹果;
  }
}
son(){
  while(1){
    P(orange);
    P(mutex);
    取出一个橙子;
    V(mutex);
    V(plate);
    吃橙子;
  }
}
```



### 吸烟者问题

![WeChata59fde3cce7f4e51f69ea5ecac84f595.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnk2hoza6xj31ok0wo7wj.jpg)

```c
semaphore offer1 = 0;  
semaphore offer2 = 0;
semaphore offer3 = 0;
// 抽烟是否已经完成
semaphore finish = 0;
semaphore mutex = 1;

provider(){
  while(1){
    P(mutex);
    将组合一放桌子上;
    V(mutex);
    V(offer1);
    P(finish);

    P(mutex);
    将组合二放桌子上;
    V(mutex);
    V(offer2);
    P(finish);

    P(mutex);
    将组合三放桌子上;
    V(mutex);
    V(offer3);
    P(finish);
  }
}

smoker1(){
  while(1){
    P(offer1);
    P(mutex);
    从桌子上拿走组合1;
    V(mutex);
    V(finish);
  }
}

smoker2(){
  while(1){
    P(offer2);
    P(mutex);
    从桌子上拿走组合2;
    V(mutex);
    V(finish);
  }
}

smoker3(){
  while(1){
    P(offer3);
    P(mutex);
    从桌子上拿走组合3;
    V(mutex);
    V(finish);
  }
}
```



### 读者写者问题

![WeChatc145b7c64a86a3f1b0bd75bceac53744.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnkflu93isj31o00v84qr.jpg)

![WeChat06a0b8f6ab4a862e03e5113a6586d678.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnkfmrezxmj31nc0uoe84.jpg)

```c
//用于实现对文件互斥访问。表示当前是否有进程访问共享文件
semaphore rw = 1;
// 记录当前几个读进程在访问文件
count = 0;
// 用于对count变量互斥访问 (很重要)
mutex = 1;
// 本算法读进程优先，如果读进程源源不断，写进程会饿死。
// 加入w实现读写公平法
w = 1;
```

```c
writer(){
  P(w);
  P(rw);
  写文件;
  V(rw);
  V(w);
}

reader(){
  P(w);
  P(mutex);
  if(count==0)
    P(rw);
  count++;
  V(mutex);
  V(w);
  读文件;
  P(mutex);
  count--;
  if(count==0)
    V(rw);
  V(mutex);
}
```

核心思想设计了一个**计数器count**用来记录当前共享文件读进程数。

然而对count的检查和修改**不具有原子性**导致了一些错误，用mutex**互斥信号量**解决。

**写进程饥饿问题**增加了w互斥信号量，实现**读写公平**。



### 哲学家进餐问题

![WeChat9c4ce72ab107e12d9747c1b93a63d91f.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnkww6xzusj32ik1c8x6w.jpg)

**如何防止死锁的发生？**

1. 可以对哲学家进程是假限制条件，最多允许四个哲学家同时进餐。这样保证至少有一个哲学家是可以拿到左右两只筷子的。

   ```c
   // 最多4人进餐
   semophroe mutex = 4;
   semaphore chopstick[5] = {1,1,1,1,1};
   Pi(){
     while(1){
       P(mutex);
       P(chopstick[i]);
       P(chopstick[(i+1)%5]);
       吃饭;
       V(chopstick[i]);
       V(chopstick[(i+1)%5]);
       V(mutex);
       思考;
     }
   }
   ```

   

2. 要求奇数号哲学家先拿左边块子，然后再拿右边块子，偶数号哲学家相反。用这种方法保证了相邻两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会阻塞。这就避免了占有一只后再等待另一只的情况。

   ```c
   semaphore chopstick[5] = {1,1,1,1,1};
   Pi(){
     while(1){
       if(i%2==1){
         // 奇数先左后右
         P(chopstick[i]);
         P(chopstick[(i+1)%5]);
       }else{
         // 偶数先右后左
         P(chopstick[(i+1)%5]);
         P(chopstick[i]);
       }
       吃饭;
       V(chopstick[i]);
       V(chopstick[(i+1)%5]);
       思考;
     }
   }
   ```

   

3. 仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子。

   (不能保证只有两边都能用的时候，哲学家才拿起筷子，只能说拿筷子这事是互斥执行，保证了有一个哲学家在拿筷子拿到一半被阻塞，也不会有别的哲学家会尝试拿筷子)。

   ```c
   semaphore chopstick[5] = {1,1,1,1,1};
   semaphore mutex = 1; //互斥地取筷子 (只是取筷子)
   Pi(){
     while(1){
       P(mutex);
       P(chopstick[i]);
       P(chopstick[(i+1)%5]);
       V(mutex)
       吃饭;
       V(chopstick[i]);
       V(chopstick[(i+1)%5]);
       思考;
     }
   }
   ```

   

### 管程

管程是一种特殊的软件模块，组成部分：

1. 局部于管程的**共享数据结构**说明;
2. 对该数据结构进行操作的**一组函数**;
3. 对局部于管程的共享数据设置初始值的语句;
4. 管程有一个名字。



管程的基本特征：

1. 局部于管程的数据只能被局部于管程的过程所访问;
2. 一个进程只有通过**调用管程内的函数**才能进入管程访问共享数据；
3. **每次仅允许一个进程在管程内执行某个内部函数**。



#### 管程解决生产者消费者问题

```c
monitor ProducerConsumer
  condition full,empty;
	int count = 0;

	void insert(Item item){
    if(count==N)
      wait(full);
    count++;
    insert_item(item);
    if(count==1)
      signal(empty);
  }
	
	Item remove(){
    if(count==0)
      wait(empty);
    count--;
    if(count = N-1)
      signal(full);
    return remove_item();
  }
end monitor;

producer(){
  while(1){
    item = 生产一个产品;
    ProducerConsumer.insert(item);
  }
}

consumer(){
  while(1){
    item = ProducerConsumer.remove();
    消费产品item;
  }
}
```

各进程必须互斥访问管程的特性是由编译器实现的。



#### Java中类似于管程的机制

Java中，如果使用关键字synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用。

```java
static class monitor{
  private Item buffer[] = new Item[N];
  private int count = 0;
  // 如果多个线程调用insert函数,后来者需要排队等待
  public synchronized void insert(Item item){
    ...
  }
}
```



## 死锁



### 死锁的概念

互相等待对方手里的资源，导致各进程都阻塞，无法向前推进。



**产生的必要条件**(四个条件任意一个不满足，不会发生死锁)

- **互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁。
- **不剥夺条件**：进程所获得的资源未使用完之前，**不能由其它进程强行夺走**，只能主动释放。
- **请求和保持条件**：进程已经保持了至少一个资源，但有提出了新的资源请求，而该资源又被其它进程占有，此时请求进程被阻塞，但又对自己已有资源保持不放。
- **循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。



对不可剥夺资源的不合理分配可能导致死锁。



**死锁处理策略**

- 预防死锁。破坏死锁产生的四个必要条件中的一个或几个。
- 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁。(银行家算法)
- 死锁的检测和解除。允许死锁的发生，不过操作系统会负责检查出死锁的发生，然后采取某种措施解除死锁。





### 死锁的处理



#### 预防死锁

##### **破坏互斥条件**

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如：SPOOLing技术。



改造前

<img src="http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnl1kl856qj30yo0oqkjl.jpg" alt="WeChat14273f14a4f70784cd7d028d00aadf8f.png" style="zoom:50%;" />

改造后(队列思想)

![WeChat109116a712b6fc4852e052275bff85da.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnl1m4y03tj30mq08cwpa.jpg)



**缺点**

并不是所有资源都可以改造成可共享使用资源。**很多时候都无法破坏互斥条件**。



##### 破坏不剥夺条件

方案一：当某个进程请求新的资源得不到满足时，必须立即释放保持的所有资源，待以后需要时再重新申请。

方案二：当某个进程需要的资源被其它进程占有时，可以由操作系统协助，将想要的资源强行剥夺，这种方式需要考虑各进程的优先级。



**缺点**

1. 实现复杂。
2. 释放已获得资源可能造成前一阶段工作的实效。这方式只适用于易保存和恢复状态的资源，如CPU。
3. 反复申请和释放资源会增加系统开销，降低系统吞吐量。
4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。



##### 破坏请求和保持条件

可以采用静态分配方法，进程在运行前一次申请完它需要的全部资源，在它的资源未满足前，不让它投入运行。一旦运行，资源一直归它所有，不再请求别的资源。



**缺点**

资源利用率极低，可能导致某些进程饥饿 (如图中C进程)。

![WeChatd54b5c690c3a385737fb7798fc29cc73.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnl218sjf8j30oc0940z7.jpg)



##### 破坏循环等待条件

采用**顺序资源分配法**。给系统中资源编号，每个进程必须按**编号递增的顺序**请求资源，同编号资源一次申请完。

原理分析：一个进程只有已占有小编号资源时，才能请求大编号资源。已持有大编号资源不可请求小编号资源，从而不会产生循环等待。

**缺点**

- 不方便增加新设备，可能需要重新分配编号
- 进程实际使用资源顺序可能和递增顺序不一致，资源浪费。



#### 避免死锁

**安全序列**时指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找到一个安全序列，系统就是**安全状态**。

在资源分配之前**预先判断**这次分配是否会导致系统进入不安全状态，以此来决定是否答应资源分配请求。“**银行家算法**”思想。



系统总资源(10,5,7). 剩余可用资源(3,3,2)

![WeChat80213001f606f79b7ecbf4054f66b4b2.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnl40es5c2j30l4098alv.jpg)

安全序列： {P1,P3,P0,P2,P4}



**银行家算法步骤**

1. 检查此次申请是否超过了之前声明的最大需求数
2. 检查此次系统剩余的可用资源是否还能满足这次请求
3. 试探着分配，更改数据结果
4. 用安全性算法检查本次分配是否会导致系统进入不安全状态



**安全性算法**

检查当前剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的全部资源回收。

不断重复上述过程，看最终能否让所有进程加入安全序列。

系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。



#### 死锁检测与解除

**死锁检测**



![WeChatfb70749d0718c024e56ea55af5b76451.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnl4jihayfj30tg0aw4ap.jpg)

![WeChatef000f8913613bf1d79e4c743f10fb5c.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnl4l5gz5cj315g0b01kx.jpg)



**死锁解除**

1. 资源剥夺法。

   **挂起**(暂时放到外存)某些死锁进程。

2. 撤销进程法

   强制撤销部分、甚至全部死锁进程。

3. 进程回退法

   回退一个或多个死锁进程至足以避免死锁的地步。要求系统记录进程执行信息，设置还原点。



**决定对谁动手**

1. 优先级
2. 已执行多少时间
3. 还要多久完成
4. 进程使用了多少资源
5. 进程是交互式还是批处理式



------

# 第三章

## 内存

### 内存基础知识

内存地址从0开始，每个地址对应一个存储单元。



存储单元大小

- 按字节编址

  大小为一个字节，即1B，8个二进制位

- 按字编址

  字长为16位的计算机，每个存储单元大小为一个字，16个二进制位



相对地址又称逻辑地址，绝对地址又称物理地址。



**从写程序带查询运行**

![WeChat1c1f163d5fdcc65553dbf5770777ea7b.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnl56s97epj31bs0jw7p5.jpg)

1. 编译

   由源代码文件生成目标模块(高级语言->机器语言)

2. 链接

   由目标模块生成装入模块，链接后形成完整的逻辑地址

3. 装入

   将装入模块装入内存，装入后形成物理地址



**链接的三种方式**

1. 静态链接

   装入前链接成一个完整装入模块

2. 装入时动态链接

   运行前边装入边链接

3. 运行时动态链接

   运行时需要目标模块才装入并链接





**装入的三种方式**

1. 绝对装入

   在编译时，如果知道程序将放到内存中哪个位置，编译程序将产生绝对地址的目标代码。

   绝对装入只适用于单道程序环境。

2. 静态重定位

   又称可重定位装入。编译、链接后的装入模块地址从0开始，都是相对起始地址的逻辑地址。装入时对地址进行“重定位”，将逻辑地址转换为物理地址。

   作业装入内存时，必须分配其要求的全部内存空间，如果没有足够内存，就不能装入。作业一旦进入内存，运行期间不能再移动，也不能再申请内存空间。

3. 动态重定位

   动态运行时装入。编译、链接后的装入模块地址从0开始。装入程序吧装入模块装入内存后，并不会立即把逻辑地址转为物理地址，而是推迟到程序真正要执行时才进行。这种方式需要**重定位寄存器**支持。

   允许程序在内存发生移动。

   ![WeChatf9564f4967c7e02c44237b99e7529a35.png](http://ww1.sinaimg.cn/mw690/008aPpVGgy1gnl5jrzc7pj312a0h0nhh.jpg)



------

### 内存管理的概念

1. 操作系统负责**内存空间的分配与回收**
2. 操作系统需要提供某种技术从逻辑上**对内存空间进行扩充**
3. 操作系统提供地址转换过程，负责程序的**逻辑地址与物理地址转换**
4. 操作系统要提供**内存保护**功能。保证各进程在各自存储空间内运行，互不干扰。
   - 设置上下限寄存器
   - 利用重定位寄存器、界地址寄存器进行判断

------

### 内存空间的扩展

- 覆盖技术
- 交换技术
- 虚拟存储技术



#### 覆盖技术

将程序分为多个模块。常用的段常驻内存，不常用的在需要时调入内存。

内存在分为一个"**固定区**"和若干个"**覆盖区**"。

需要常驻内存的段放在固定区，调入后就不再调出(除非运行结束)

不常用的段放在覆盖区，需要用到时调入内存，用不到时调出内存

![WeChat2b6a7a1bb29e36757cae390ab8664318.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnl6r99womj31860j04ij.jpg)

**必需由程序员声明覆盖结构**，操作系统完成自动覆盖。缺点：**对用户不透明**，增加编程负担。



#### 交换技术

内存空间紧张时，操作系统将内存中某些进程暂时**换出**外存，把外存中某些已具备运行条件的进程**换入**内存(进程在内存与磁盘间动态调度)



1. 应该在外存(磁盘)什么位置保存被换出的进程？

   具有对换功能的操作系统，通常磁盘空间分为**文件区**和**对换区**两部分。对换区占磁盘空间很小部分。对换区空间的管理主要追求**换入换出速度**，因此通常采用**连续分配方式**。总之，**对换区的I/O速度比文件区更快**。

2. 什么时候交换？

   许多进程运行且内存紧张。

3. 应该换出哪些进程？

   可优先换出阻塞进程；优先级低进程；也可以考虑进程在内存驻留时间。

**PCB会常驻内存**，不会被换出到外存。



#### 虚拟存储技术

传统存储管理的特征(连续、非连续)

- 一次性

  作业必须一次性全部装入内存后才能开始运行。

  - 作业很大时，不能全部装入内存，导致**大作业无法运行**；
  - 当大量作业要求运行时，由于内存无法容纳所有作业，只有少量能运行，导致**多道程序并发度下降**。

- 驻留性

  一旦作业被装入内存，就**会一直驻留在内存**中，直到作业运行结束。

基于局部性原理，在程序装入时，可以将程序中**很快用到的部分装入内存**，**暂时用不到的部分留在外存**。

在程序执行过程中，当访问的信息不在内存时，**由操作系统负责将信息从外存调入内存**，然后继续执行。

若内存空间不够，**操作系统将内存中暂时用不到的信息换出到外存**。

在操作系统的管理下，用户看起来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**。

![WeChat2afbf64cd5019b493be9c0892a277755.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnmf4u71rjj315k0a8kav.jpg)



**虚拟内存的三个主要特性**

- 多次性

  无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存

- 对换性

  在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。

- 虚拟性

  从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。



**如何实现虚拟内存技术**？

虚拟内存技术如果采用连续分配方式，会不方便实现，因为需要多次调入。因此，虚拟内存的实现需要建立在**离散分配**的内存管理方式基础上。

- 请求分页存储管理
- 请求分段存储管理
- 请求段页式存储管理



操作系统需在非连续分配管理方式上，提供额外功能

- 提供请求调页(或请求调段)功能

  访问的信息不在内存，操作系统从外存将其调入内存

- 页面置换(段置换)功能

  将内存暂时用不到信息换出到外存

  

------



### 内存空间的分配与回收

#### 连续分配管理方式

##### 单一连续分配

内存被分为**系统区**和**用户区**。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnl79xlbzfj30ak0jowh3.jpg" alt="WeChat4ebcf0c67f10de9a04b8a613e1fd3b32.png" style="zoom:33%;" />

内存中**只能由一道用户程序**，用户程序独占整个用户区空间。

优点：实现简单；**无外部碎片**;可以采用覆盖技术扩充内存;不一定需要采取内存保护。

缺点: 只用于单用户、单任务的操作系统；**有内部碎片**；内存利用率低。



##### 固定分区分配

整个用户空间划分为若干个固定大小分区，在每个分区只能装入一道作业。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnl7m30rhpj30hq0jmgyj.jpg" alt="WeChat62d668952f14f91456b9d5715df26100.png" style="zoom: 33%;" />

操作系统需要建立一个数据结构——**分区说明表**，来实现各个分区的分配与回收。每个表项包括对应分区的**大小、起始地址、状态**(是否已分配)。

![WeChatee5dc3a12c263d12237d737ee9d27e5f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnl7qhwyclj30o407k0zc.jpg)



优点：实现简单，无外部碎片。

缺点：a.当用户程序太大，可能所有分区都不能满足，此时需要采用覆盖技术，会降低行呢呢个；b.会产生内部碎片，内存利用率低。



##### 动态分区分配

又称**可变分区分配**。**不会预先划分内存分区**，而是在进程装入内存时，**根据进程大小动态建立分区**。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnl80b3b8qj30980euq7f.jpg" alt="WeChat6aa3edb0685a75089227ca397d2d0bc1.png" style="zoom:33%;" />

1. 用什么数据结构记录内存使用情况？

   - 空闲分区表

     ![WeChatd11c345eba24ab10ba0bdac9222b1538.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnl7yuyz9tj30mg05s7a0.jpg)

   - 空闲分区链

     ![WeChatae655fbc4d5e325e87ec749a0bf4319d.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnl7zxfm5ij30n4032dhs.jpg)

2. 很多个空闲分区都能满足需求时，应该选哪个进行分配？

   需要按照**动态分区分配算法**。

3. 如何进行分区的分配与回收操作？

   **分配时**：修改空闲分区表的起始地址和分区大小，可能需要删除某一行。

   **回收时**：修改空闲分区表的起始地址和分区大小，可能需要添加某一行或删除某一行。



动态分区分配**没有内部碎片**，但是**有外部碎片**。

可以通过**紧凑(拼凑,Compaction)**技术来解决外部碎片。紧凑后需要修改内存的起始地址。

------







#### 非连续分配管理方式

##### 基本分页存储管理

将内存空间分为一个个**大小相等的分区**，每一个分区就是一个"**页框**"，每个"页框"有一个编号，即"**页框号**"，**从0开始**。

将用户进程的地址空间也分为**与页框大小相等**的一个个区域，称为"**页**"或"**页面**"。每个页面也有一个编号，即"**页号**",页号也是**从0开始**。

(一个进程的最后一个页面可能没有页框大。因此，**页框不能太大**，否则会产生**过大内部碎片**)

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnlkp7u5vrj30l80rgqhb.jpg" alt="WeChat447affd24a0be5cb360122b1cdc105ba.png" style="zoom:33%;" />

操作系统以**页框为单位为各个进程分配内存空间**。

各个页面不必连续存放，也不必按先后顺序，可以放到不相邻的各个页框中。



**如何实现地址的转换？**

![WeChatc2254eec8c759cc587edd722fc9580da.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnlkxk83kyj31ik0vsu0x.jpg)

找逻辑地址为80的内存单元。在第一号页，第一号页在内存中**起始地址**为450，**偏移量**为30。

所以**实际物理地址** = 450 + 30 = 480

1. 算出逻辑地址对应的**页号**

2. 要知道页号对应**页面在内存中的起始地址**

3. 算出逻辑地址**在页面内的"偏移量"**

4. **物理地址=页面起始地址+偏移量**

   

页号 = 逻辑地址 / 页面长度

页内偏移量 = 逻辑地址 % 页面长度

页面**在内存中的起始位置**：操作系统需要用某种数据结构记录进程各个页面的起始位置



为了方便计算页号、页内偏移量，页面大小一般要为**2的整数幂**

![WeChat87313fc8f951b2e329628111340fc6ca.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnllafampfj31gw0ji1ky.jpg)

结论: 如果每个页面大小为2^K B，用二进制表示逻辑地址，则末尾K位即为**页内偏移量**，其余部分就是**页号**。

![WeChatb958b50646f90dac232fc7fa347ccdd3.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnllemqetxj31f60diaw3.jpg)



**页表**

为了知道进程每个页面在内存中存放的位置，操作系统要**为每个进程建立一张页表**。

![WeChat442b4b12c6ba4955f3f8c8fe5a2fd180.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnllia6uyqj31fi0mie6l.jpg)

M号内存块的起始地址 = M * 内存块大小



**每个页表的长度是相等的，页号是“隐含”的**。

![WeChat6046b7b9aa958d438764829efdd61413.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnllu114hwj31es0pgnpd.jpg)



------

##### 基本分段存储管理

![WeChatb7558225445bd7fd903c30274a17bdcc.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm5ia9vudj31gk0qou0x.jpg)



![WeChata25222be85a0ab5fa0fc302635337b11.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm5l9oe1xj31he0rcu0x.jpg)



程序分为多个段，各段离散地装入内存。每个进程建立一张段映射表，简称“**段表**”。

![WeChat811265484dc140a1c41e36a66003951f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm5nlurkhj31b40k4wyl.jpg)

1. 每个段对应一个段表项，记录了该段在内存中的**起始位置(基址)**和**段的长度**。
2. 各个段表项长度相同。**段号可以时隐含的，不占存储空间**。若段表存放的起始位置为M，第K号段对应段表项存放地址为**M+K*段表项大小**

![WeChat37a4c7a26a15e17b0b4487c46e419d53.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm5zacw3ej31kg0w87wi.jpg)





**分段、分页管理的对比**

**页**是**信息的物理单位**。分页的目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，**对用户是不可见的**。

**段**是**信息的逻辑单位**。分段的目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。**分段对用户是可见的**，用户编程时需要显式地给出段名。



页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。



**分页**的用户进程**地址空间是一维**的，程序员只需给出一个记忆符即可表示一个地址。

**分段**的用户进程**地址空间是二维**的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

![2241613225878_.pic.jpg](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm9ox6oomj30rj07fgml.jpg)



**分段**比分页**更容易实现信息的共享和保护**。



分段下的信息共享保护

![WeChat19b0b8af7e5b337defd510a242285202.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm9r72w0rj316q0ma1kx.jpg)



分页下的信息共享保护

![WeChate7a3c6cfcef0d3d1110efefc4917c3cc.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm9sg2jcqj30yc0jau0o.jpg)



分段：第一次访存——查询内存中的段表，第二次访存——访问目标内存单元。

在分段中，也可以引入**快段机构**，将近期访问过的段表项放到快表中。

------

##### 段页式存储管理

|          | 优点                                                   | 缺点                                                         |
| -------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| 分页管理 | 内存空间利用率高，不会产生外部碎片，只会有少量页内碎片 | 不方便按照逻辑模块实现信息的共享和保护                       |
| 分段管理 | 很方便按照逻辑模块实现信息的共享和保护                 | 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片 |

![WeChatdbda642dff9dd860efab1d40ecc0afca.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnma3091vhj31bk0qanl3.jpg)

将进程按逻辑模块分段，再将各段分页

再将内存空间分为大小相同的内存块/页框/页帧/物理块

![WeChatabf7bcd066f1a9894ebe14ab51c73f51.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnma5lvcn3j315e086dpm.jpg)

“分段”对用户是可见的，程序员需要显式给出段号、段内地址。而将各段”分页“对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。

因此**段页式**管理的**地址结构是二维**的。



![WeChat631d2f9a24e0718498e42ac5fd690109.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnmacgw94hj31em0nm7wh.jpg)

每个段对应一个段表项，每个段表项由段号、**页表长度、页表存放块号(页表起始地址)**组成。每个**段表项长度相等，段号是隐含的**。

每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。

![WeChatd6f0be08432fe578a42837ffeb55c104.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnme4r7h4fj31kw0vqkjm.jpg)

第一次访存——查段表，第二次访存——查页表，第三次访存——访问目标单元

可以**引入快表**，这样如果快表命中，仅需**一次访存**。

------

### 动态分区分配算法

#### 首次适应算法(First Fit)

每次从**低地址开始**查找，找到**第一个**能满足大小的空闲分区。





#### 最佳适应算法(Best Fit)

空间分区按**容量递增**次序链接。每次分配内存时顺序查找空闲分区表/链，找到**大小能满足**要求的**第一个**空闲分区。

缺点: 每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。产生很多**外部碎片**。

优点：更可能把高地址的大分区保留下来。

#### 最坏适应算法(Worst Fit)

又称**最大适应算法(Largest Fit)**

为了解决最佳适应算法的问题——留下太多难以利用的小碎片。 可以在每次分配时优先**使用最大的连续空闲区**，这样分配后剩余的空闲去就不会太小。

缺点：每次都选最大的分区进行分配，这种方式导致**较大的连续空闲区被迅速用完**。如果有“大进程到达”，就没有内存分区可用了。



#### 临近适应算法(Next Fit)

思想：首次适应算法每次从链投开始查找。这可能导致低地址部分出现很多小的空闲分区，每次分配查找时，都要经过这些分区，增加了查找开销。如果**每次从上次查找结束的位置开始索引**，就能提高索引速度。

实现：空闲分区以**地址递增**的序列排序(**循环链表**)。每次分配内存时**从上次查找结束的位置开始查找**空闲分区链(表),找到大小满足要求的第一个空闲分区。

缺点：无论低地址、高地址部分的空闲分区都有**相同概率**被使用，导致了**高地址部分的大分区更可能被使用**，划分为小分区，最后无大分区可用。

| 算法     | 思想                                               | 分区排序顺序                     | 优点                                                         | 缺点                                                         |
| -------- | -------------------------------------------------- | -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | 从头到位找适合的分区                               | 以地址递增次序排列               | 综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序 |                                                              |
| 最佳适应 | 优先使用更小的分区，以保留更多大分区               | 空闲分区以容量递增次序排列       | 保留更多大分区                                               | 产生太多太小、难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 | 优先使用更大的分区，防止产生太小的不可用碎片       | 空闲分区以容量递减次序排列       | 可以减少难以利用的小碎片                                     | 大分区容易被用完。不利于大进程；算法开销大，回收后可能需要重新排序。 |
| 临近适应 | 由首次适应演变而来，每次从上次查找结束为止开始查找 | 空闲分区以地址递增排序(循环链表) | 不用每次从低地址的小分区开始检索了算法开销小，回收后不需要重新排序。 | 会使高地址的大分区也被用完                                   |

**综合来说，首次适应算法的效果反而更好**

------



### 基本地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常在系统中设置一个页表寄存器(PTR)，存放**页表在内存中的起始地址F**和**页表长度M**。进程未执行时，页表的始址和页表长度**放在进程控制块(PCB)**中，当进程被调度时，操作系统内核会把它们放到页表寄存处中。

![WeChat62583d25b56e2d98b18437d195999ca8.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnlmc36lnpj31kk0ughdt.jpg)



注意：**页面大小为2的整数幂**

设页面大小为L，逻辑地址A到物理地址E的变换过程如下：

1. 计算页号P和页内偏移量W (计算机二进程更快)

   P = A/L

   W=A%L

2. 比较页号P和页表长度M，若P>=M,产生越界中断，否则继续执行。(页号从0开始，而页表长度至少是1，因此P=M也会越界)

3. 页表中页号对应的**页表项地址 = 页表起始地址F + 页号*页表项长度**，取出该页表项内容b,即为内存块号。

4. E = b * L + W, 用得到的物理地址E去访存。(二进制内存块号，偏移量拼接更快)



有2次内存访问

第一次：查页表

第二次：访问目标内存单元



**页式管理中地址是一维的**，只需要逻辑地址就能找到物理地址。



![WeChatfb614562c92316f549739961d4efef31.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnlmtaqylyj31ks0ukb2a.jpg)

页表项长度的设计有技巧！设置成**能够正好占满的**

为了方便找到页表项，页表一般是放在**连续的内存块**中的。

------

### 具有快表的地址变换机构

基本地址变换机构的改进版本



**局部性原理**

- **时间局部性**

  如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行；如果某个数据被访问过，不久之后该数据可能再次被访问。

- **空间局部性**

  一旦程序访问了某个存储单元，不久之后，其附近的存储单元很可能被访问。(很多数据在内存中连续存放)

由于局部性原理，可能连续很多次查到的都是同一个页表项。



**快表**，又称**联想寄存器(TLB)**,是一种**访问速度比内存快很多**的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为**慢表**。



![WeChat2d4360dd427b91c7bf01a2d82d817dd6.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm3qdyr4kj31jw0vqhdt.jpg)



**快表命中**，访问某个逻辑地址仅需**一次**访存。

**快表未命中**，访问某个逻辑地址需要**两次**访存。

|                        | 地址变换过程                                                 | 访问一个逻辑地址的访存次数                           |
| ---------------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| 基本地址变换机构       | 1.算页号，页内偏移量<br />2.检查页号合法性<br />3.查页表，找到页面存放的内存块号<br />4.根据内存块号与页内偏移量得到物理地址<br />5.访问目标内存单元 | 两次访存                                             |
| 具有快表的地址变换机构 | 1.算页号，页内偏移量<br />2.检查页号合法性<br />3.查快表。若命中，即可以知道页面存放的内存块号，直接执行5；若未命中则进行4<br />4.查页表，找到页面存放的内存块号，并将页表项复制到快表中<br />4.根据内存块号与页内偏移量得到物理地址<br />5.访问目标内存单元 | 快表命中，只需一次访存<br />快表未命中，需要两次访存 |

------



### 两级页表

![WeChatdcfae9b07e7acd77f8dda12519ccb6e9.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm4egc5anj31g20tyqv5.jpg)



单级页表存在的问题

1. **页表必须连续存放**，页表很大时，需要**占用很多个连续的页框**。
2. **没必要让整个页表都常驻内存**，进程在一段时间内只需要访问某几个页面就可以正常运行了。

可以将尝尝的页表进行分组，使每个内存块刚好可以放入一个分组(如果页面大小4KB，每个页表项4B，每个页面可以存放1K个页表项，因此每1K个连续的页表项为一组，再将各组离散地放到各个内存块中)

要为离散分配的页表再建立一张页表，称为**页目录表**，或称**外层页表**，或称**顶层页表**。

![WeChat199723f1c9141f41df6c905a46e215db.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm4vh8mmxj31ig0rmb29.jpg)

![WeChat687f41a3bd9fc4a2729dbe31e5f7b7fe.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm4xi2a9zj31hq0ueqv5.jpg)

![WeChat989d894d693ca7e06e692168f0e566fa.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnm4zfi5xlj31ek0pinpd.jpg)

需要用到二级页表时，再将其整块调入页框



1. 若采用多级页表机制，**各级页表的大小不能超过一个页面**

2. 两级页表的**访存次数**分析(假设没有快表机构)

   第一次：访问内存中的页目录表

   第二次：访问内存中的二级页表

   第三次：访问目标内存单元

------

### 请求分页存储方式

请求分页存储管理是在基本分页存储管理的基础上，结合虚拟存储技术实现的。



#### 页表机制

与基本分页管理相比，请求分页管理为了实现“**请求调页**”，操作系统需要知道每个页面**是否已经调入内存**；如果没调入，需要知道页面在**外存中存放的位置**。

当内存空间不够时，要实现“**页面置换**”，需要决定**换出哪个页**；有的页没有被修改过，就不用浪费时间写回外存。有的页面修改过，需要**将外存旧数据覆盖**，因此，操作系统也需要**记录各个页面是否被修改的信息**。

![WeChat7fa75e3829dc8d280801388e42600136.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnmi75z8qij31hk0f8e81.jpg)



#### 缺页中断机构

在请求分页系统中，每当要访问的**页面不在内存**时，便产生一个**缺页中断**，然后操作系统的**缺页中断处理程序处理中断**。

**缺页中断**属于**内中断**。

**一条指令**在执行期间，可能产生**多次缺页中断**。

此时**缺页的进程阻塞**，放入阻塞队列，调页**完成后再将其唤醒**，放回就绪队列。



如果内存中**有空闲块**，则为进程**分配一个空闲块**，将所缺页面装入该块，并修改页表中相应的页表项。

如果内存中**没空闲块**，则由**页面置换算法选择一个页面淘汰**，若该页面在内存期间**被修改过**，则要将其**写回外存**。未修改过的页面不用写回外存。



新增步骤1：请求调页

新增步骤2:   页面置换

新增步骤3:   需要修改请求页表中新增的表项

![WeChatd09718e2004f210209e0d3f040a335f9.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnmk98j56xj31ki0v4x6p.jpg)



------

### 页面置换算法

选择把内存中哪个页面换到外存。

好的页面置换算法**追求更少的缺页率**。



#### 最佳置换法(OPT)

每次选择**淘汰的页面**是**以后永不使用**，或者**在最长时间内不被访问**的页面。

最佳置换算法可以保证最低的缺页率，但实际上，只有进程执行的过程中才知道接下来访问哪个页面。操作系统无法提前预判页面访问序列。因此，**最佳置换算法是无法实现的**。

#### 先进先出置换算法(FIFO)

维护一个队列，最先进的最先出



**Belady异常**——当为进程分配的物理块增大时，缺页次数不减反增的异常现象。

**只有FIFO会有Belady异常**。FIFO虽然实现**简单**，但与实际运行规律不符合。**算法性能差**。



#### 最近最久未使用置换算法(LRU)

每次**淘汰的是最近最久未使用页面**。

实现方法：赋予每个页面对应的页表项中，用**访问字段记录该页面自上次被访问以来所经历的时间t**。

当要淘汰一个页面时，**选t最大值**。

![WeChatd3d293a7a59aaf57d1b060426ccff29f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnmnwmlwe5j30xw02cgrk.jpg)



该算法实现需要专门硬件支持，虽然**算法性能好**，但是**实现困难，开销大**。



#### 时钟置换算法(CLOCK)

性能和开销较为均衡。又称**最近未用算法(NRU**,Not Recently Used)



**简单CLOCK算法**

为每一页面设置一个**访问位**，再将内存中的页面都通过指针链接成一个**循环队列**。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果时0，就选择将该页换出；如果时1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有都是1，则将这些页面访问位依次置为0后，再进行第二轮扫描(第二轮扫描一定会有0，因此，简单的CLOCK淘汰一个页面**最多会经过两轮扫描**)

**指针一直往前移**

![WeChatfd93f951b9317d230e453f31bbbd2799.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnmo875o0pj31hi0eg7uv.jpg)





#### 改进型的时钟置换算法

简单的时钟置换算法仅考虑到一个页面最近是否被访问过。

如果被淘汰页面**没被修改过，不需要执行I/0操作写回外存**。

除了考虑一个页面最近有没有被访问过之外，操作系统还要考虑页面有没有修改过。**在其他条件都相同时，优先淘汰没有被修改过的页面**，避免I/O操作。

修改位=0，没被修改；修改位=1，被修改。



![WeChat465a26456f858a3ea8d2a521f52c4f81.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnmohrd3z9j31hk0jwkjl.jpg)

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnmokux2cnj30f60e4kaf.jpg" alt="WeChat8279f57b65e3dbad9e3671447fbd9fbf.png" style="zoom:33%;" />

改进型CLOCK置换算法在选择淘汰一个页面**最多进行四轮扫描**。



|             | 算法规则                                                     | 优点                   | 缺点                       |
| ----------- | ------------------------------------------------------------ | ---------------------- | -------------------------- |
| OPT         | 优先淘汰最长时间内不会被访问的页面                           | 缺页率最小，性能最好   | 无法实现                   |
| FIFO        | 优先淘汰最先进入的页面                                       | 实现简单               | 性能差，可能出现Belady异常 |
| LRU         | 优先淘汰最近最久没访问页面                                   | 实现简单               | 需要硬件支持，开销大       |
| CLOCK(NRU)  | 循环扫描各页面<br />第一轮淘汰访问位=0，并将扫描过的页面访问位改为0。若第一轮没选中，则进行第二轮扫描。 | 实现简单，算法开销小   | 未考虑页面是否被修改       |
| 改进型CLOCK | 若用(访问位，修改位)形式表述，则<br />第一轮 淘汰(0,0)<br />第二轮 淘汰(0,1),并将扫描过的页面访问位都置为0<br />第三轮 淘汰(0,0)<br />第四轮 淘汰(0,1) | 算法开销小，性能也不错 |                            |

------

### 页面分配策略

驻留集：指请求分页存储管理中给进程分配的物理块的集合。

在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。

如果驻留集太小，缺页频繁。系统花大量时间处理缺页。

如果驻留集太大，多道程序并发度下降，资源利用率低。



**分配方式**

- 固定分配

  操作系统未每个进程分配一组固定数目的物理块，在进程运行期间不再改变。**驻留集大小不变**。

- 可变分配

  先为每个进程分配一定数目的物理块，运行期间根据情况增加或减少。**驻留集大小可变**。



**置换范围**

- 局部置换

  发生缺页时只能选进程自己的物理块进行置换。

- 全局置换

  可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。



![WeChatdcf33c3aa9c0d67da515a4044163aa6a.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnmpykrr2nj30wu08c7h4.jpg)



- 固定分配局部置换

  系统为每个进程分配一定数量物理块，在整个运行期间都不改变。若发生缺页，只能从该进程在内存中的页面选一页换出。

  缺点：很难一开始知道给每个进程分配多少个物理块才合理。(可根据进程大小，优先级分配)

- 可变分配全局置换

  系统为每个进程分配一定数量物理块。操作系统保持一个空闲物理块队列。当缺页时，从空闲物理块取一块分配给该进程；若已无空闲物理块，则可选择一个**未锁定**的页面换出到外存。本策略**只要进程发生缺页，都将获得新物理块**，仅当空闲物理块用完时，才选择一个未锁定页面调出。被选择调出的页可能是任意一个进程的页。

- 可变分配局部置换

  系统为每个进程分配一定数量物理块。发生缺页时，只允许从该进程自己物理块中选一个换出到外存。如果频繁缺页，系统将为进程分配物理块，知道缺页率趋势适当。如果缺页率特别低，可适当减少分配给该进程的物理块。

  

**何时调入页面**

- 预调页策略

  根据局部性原理，一次调入若干个相邻页面可能比一次调入一个更高效。当预测成功率不高。**主要用于进程的首次调入**，程序员指出先调入哪些。

- 请求调页策略

  进程在**运行期间发现缺页才调入内存**。I/O开销较大。



**从何处调入页面**

- 系统拥有足够的对换区空间

  页面的调入，调出都是在内存与对换区之间进行。

  <img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnmqgyl7j5j30ro0lak9a.jpg" alt="WeChatb61c3e78010f27d145e887b1193f092f.png" style="zoom: 33%;" />

- 系统缺少足够的对换区空间

  凡是不会被修改的数据直接从文件区调入。可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。

  <img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnmqk7ureoj30qc0nax4s.jpg" alt="WeChatd40ff20ede4141af575f4bab4788d346.png" style="zoom:33%;" />

- UNIX方式

  运行之前进程有关数据全部放在文件去，故未使用过的页面都可从文件区调入。若使用过页面需要换出，则写回对换区，下次需要再从对换区调入。

  <img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnmqmycdptj30pk0m0ari.jpg" alt="WeChata71a8928845efc0e2ad8e6bd194ef33e.png" style="zoom:33%;" />



**抖动(颠簸)现象**

刚刚换出的页面马上要换入内存，刚刚换入的页面马上又要换出内存。这种频繁的页面调度行为称为**抖动，或颠簸**。主要原因是**分配给进程的物理块不够**。



**工作集**

指在某段时间间隔里，进程实际访问页面的集合

系统通过检测工作集的大小(可看出局部性关系)，来动态决定给进程分配多少内存块(驻留集大小)。

一般来说，**驻留集大小不能小于工作集大小**，否则进程**频繁缺页**。

------



# 第四章

## 文件

### 初识文件管理



**一个文件拥有的属性**

- 文件名

- 标识符

  唯一，对用户毫无可读性。

- 类型

- 位置

- 大小

- 创建时间、上次修改时间

- 文件所有者信息

- 保护信息



**文件内部数据如何组织？**

- 无结构文件

  如文本文件，由一些二进制或字符流组成，又称"流式文件"。

- 有结构文件

  如数据库表，由一组相似的记录组成，又称"记录式文件"。



**操作系统应该向上提供哪些服务**？

- create系统调用

- read系统调用

  文件从外存调入内存。

- write系统调用

  文件数据从内存写回外存。

- delete系统调用

  从外存删除文件。

- open系统调用

- close系统调用



------

### 文件的逻辑结构

- 无结构文件

  流式文件，二进制流或字符流组成

- 有结构文件

  由一组相似的记录组成，又称”记录式文件“。

  根据各条记录长度(占用的存储空间)是否相等，又可分为**定长记录**和**可变长记录**。

  ![WeChat603d8c2d1d72cd8235b510843a680359.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnn9newglfj30t0036427.jpg)

  ![WeChat5c3f9b7f71c714e32f13118c0e6a40bd.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnn9nupyo3j30qq03awiw.jpg)

  - 顺序文件
  - 索引文件
  - 索引顺序文件



#### 顺序文件

文件中的记录一个接一个地顺序排列(逻辑上)，记录可以**定长**或**可变长**的。各个记录物理上可以**顺序存储**或**链式存储**。

![WeChat3379b4c06885406687373742042d0179.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnn9r2k7xzj31fi076tr2.jpg)



- 串结构

  记录之间的顺序与关键字无关(通常按存入时间决定记录顺序)

- 顺序结构

  记录之间的顺序按关键字排列





- 链式存储

  无论是定长/可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找

- 顺序存储

  - 可变长记录

    无法实现随机存取。只能从第一个依次往后找

  - 定长记录

    - 可实现随机存取。记录长度为L，第i个记录存放相对位置是i*L
    - 若采用串结构，无法快速找到某关键字对应记录
    - 若采用顺序结构，可以快速找到某关键字对应记录(二分查找)



#### 索引文件

![WeChatc01b9686cc6528a1d9c87ad9db2275a1.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnakaiz29j31ge0hwqv5.jpg)





#### 索引顺序文件

索引文件缺点：每个记录对应一个索引表项，因此索引表可能很大。如果文件的每个记录平均占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样存储空间的利用率太低。



索引顺序文件同样为文件创建一张索引表。并不是每个记录对应一个索引表项，而是**一组记录对应一个索引表项**。

![WeChat972348ab2a4740e01ff739b2bd5c1e71.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnavybh4ij30su0jwnh1.jpg)



**多级索引顺序文件**

![WeChatc1b29203562850d6f31cfd998ff36b49.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnay4mdy3j314c0jggzz.jpg)

------



### 文件目录

#### 文件控制块



![WeChat1e7dac1bb3049749c8f9b2b030ed4440.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnbtt3iljj31bu0iqhdt.jpg)

双击照片后，操作系统找到对应的目录项，从外存将"照片"目录对应的信息读入内存。

目录文件中的一条记录就是一个"**文件控制块(FCB)**"

FCB的有序集合称为“文件目录”，一个FCB就是一个文件**目录项**。

最重要、最基本的是**文件名**、**文件存放的物理地址**。

FCB实现了文件名和文件之间的映射，使用户程序可以实现"按名存取"。



**需要对目录进行哪些操作？**

- 搜索

  当用户要使用一个文件时，系统根据文件名搜索目录，找到该文件对应的目录项

- 创建文件

  创建一个新文件时，需要在其所属的目录中增加一个目录项

- 删除文件

  删除文件时，需要在目录中删除对应的目录项

- 显示目录

  用户可以请求显示目录内容，如目录中所有文件及相应属性

- 修改目录

  文件属性变化时，需要修改相应目录项(如：文件重命名)



#### 目录结构

##### 单级目录结构

整个系统只建立一张目录表，每个文件占用一个目录项。

单级目录实现了“按名存取”，但是**不允许文件重名**。

单级目录结构不适用于多用户操作系统



##### 两级目录结构

早期的多用户操作系统，采用两级目录结构。分为**主文件目录**(MFD, Master File Directory)和**用户文件目录**(UFD, User File Directory)。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnnchdqkj1j30tm0p21kx.jpg" alt="WeChatb6dddea4b7e8c540776e21dcc7fc4e06.png" style="zoom:33%;" />

**允许不同用户的文件重名**。

在目录上实现**访问限制**

当两级目录结构缺乏灵活性，用户不能对自己文件进行分类



##### 多级目录结构

又称"**树形目录结构**"

![WeChate9078a7ad035e2d73e1dc4993adb2feb.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnckg8ia8j31ce0g61kx.jpg)

各级目录用"/"隔开，**从根目录出发**的路径称为**绝对路径**。

系统根据绝对路径一层一层找下一级目录。每次**从外存读入对应目录表**。

已经调入内存的目录可以设置为当前目录。当用户想访问当前目录下某个文件，可以使用**从当前目录出发**的**相对路径**。

引入“当前目录”和“相对路径”后，**磁盘I/O次数减少**了，提升了访问文件的效率。

树形目录结构**不便于实现文件的共享**。因此，提出了“**无环图目录结构**”



##### 无环图目录结构

![WeChat39a31067a6595e841c7f139accb2ad80.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnctnopsqj31ia0ii4qp.jpg)

**可以用不同的文件名指向同一个文件**，甚至指向同一个目录(共享同一目录下的所有内容)。

需要为**每个共享结点设置一个共享计数器**，用于记录多少个地方在共享该结点。用户提出删除结点请求时，这是删除该用户PCB、并使**共享计数器减1**，并不会直接删除共享结点。

**只要共享计数器减为0，才删除结点**。

**只要一个用户修改了文件，所有用户都看得到数据变化。**



#### 索引结点(FCB改进)

操作系统在查找目录时，只需要文件名就行，其余不需要。因此可以考虑让目录表"瘦身"来提升效率。

![WeChatceef6a3e787914e43f028a60affaa860.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnndcstbsej31gi0r0kjm.jpg)

索引结点能提升系统性能，**减少I/O操作**。

当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件存放的物理位置，根据位置从外存调入。

**存放在外存**的索引结点称为"**磁盘索引结点**"，当索引结点**放入内存**后称为"**内存索引结点**"。

**内存索引结点需要增加一些信息**，比如文件是否被修改、此时多少个进程正在访问该文件等。

------

### **文件的物理结构**



**操作系统需要对磁盘块进行哪些管理**

- 对非空闲磁盘块管理
- 对空闲磁盘块的管理



文件的物理结构(文件分配方式)

- 连续分配
- 链接分配
  - 隐式链接
  - 显示链接
- 索引分配



类似于内存分页，磁盘中的存储单元也被分为一个个"块/磁盘块/物理块"。很多操作系统中，**磁盘块的大小与内存块、页面大小相同**。



在内存管理中，进程的逻辑地址空间被分为一个个页面

在外存管理中，**文件的逻辑地址被分为了一个个的文件“块”**。

于是文件的逻辑地址可以表示为(**逻辑块号，块内地址**)的形式。

用户通过操作逻辑地址操作自己的文件，**操作系统负责逻辑地址到物理地址的映射**。



### 文件分配方式



#### 连续分配

连续分配要求**每个文件在磁盘上占有一组连续的块**。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnnm6judd3j30vs0pa4qp.jpg" alt="WeChata2728cb449736d90cca67fda5a53b5e5.png" style="zoom:33%;" />

用户给出要访问的逻辑块号，操作系统通过文件对应的目录项(FCB)

**物理块号=起始块号+逻辑块号** (需验证逻辑块号是否合法)

**连续分配支持顺序访问和直接访问(即随机访问)**



读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间越长。

结论：**连续分配的文件在顺序读/写时速度最快**。



![WeChatda8e7633c01cedc2e87ca24092cdbc5e.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnmekxa5kj31g20mab29.jpg)

**连续分配不方便数据的拓展**

**离散的磁盘块不能利用**，存储空间利用率低，产生难以利用的磁盘碎片。

可以用**紧凑**来处理碎片，但耗时。



#### 链接分配

链接分配采取离散分配方式。分为**隐式链接**和**显示链接**。



##### 隐式链接

![WeChate18a3aae7f6411252174e349e60153b7.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnml99hjsj31io0peu0y.jpg)

本方法想找第i号逻辑块，总共需要i+1次磁盘I/O

**只支持顺序访问，不支持随机访问**

**查找效率低**

每个块要耗费少量存储空间存放**指向下个盘块的指针**

**方便文件的扩展**。不会有磁盘碎片问题，外存利用率高。



##### 显示链接

把用于链接文件各物理块的指针显式地存放在一张表中。即**文件分配表(FAT**, File Allocation Table)

![WeChatf918ac03288dfde8e7b211c06fefcab8.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnmsjcvwxj31h00qex6p.jpg)

**一个磁盘仅需设置一张FAT**

开机时，FAT读入内存，并常驻内存。

FAT各个表项物理上连续存储，因此“物理块号”字段可以是隐含的。

**逻辑块号转换成物理块号的过程不需要读磁盘操作**



**支持顺序访问，也支持随机访问**。由于块号转换过程不需要访问磁盘，因此**比隐式链接访问速度快**。

**不会产生外部碎片，很方便对文件进行拓展**。

缺点：文件分配表需要占用一定的存储空间。



#### 索引分配

支持离散分配，系统为**每个文件建立一张索引表**，索引表中**记录了文件的各个逻辑块对应的物理块**( 索引表功能类似于内存管理中的页表)。索引表存放的磁盘块称为**索引块**。文件存放的磁盘块称为**数据块**。

![WeChatc3bff26d84ee9f3f13ff92e78b72b766.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnn7l7m0rj31gi0mox6p.jpg)



支持随机访问，文件拓展方便。

索引表需要占用一定空间。



**如果一个磁盘块不够装下整张索引表，如何解决？**

- 链接方案

  多个索引块链接起来存放

  ![WeChat2726359d77ae9d81d2176ec82732ed85.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnnewyk4yj31gy0psx6p.jpg)

  要找到后面的索引块，需要读入前面索引块

- 多层索引

  原理类似多级页表。使第一层索引块指向第二层索引块。

  ![WeChat517f384bb9c82b6b37ffdcaca6fad514.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnnkzdyxjj31km0og4qq.jpg)

  文件最大长度 = (索引块存放索引数量)^索引级数*数据块大小

  二级索引机制下，需要3次磁盘I/O

  缺点：如果是小文件，采用K级索引，访问一个数据库页需要**K+1次I/O**

- 混合索引

  多种索引分配方式结合。一个文件的顶级索引中，既包含**直接地址索引**，也包括**一级间接索引**、还包括**两级间接索引**。

  ![WeChatda443db97716ba49b7a866b2b945eb51.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnnswl8dgj31ig0mwqv5.jpg)

  优点：**小文件访问一个数据块I/O次数少**

|                | how                                                          | 目录项内容                                                   | 优点                                                         | 缺点                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 顺序分配       | 为文件分配的必须是连续磁盘块                                 | 起始块号、文件长度                                           | 顺序存取速度快，支持随机访问                                 | 会产生碎片，不利于文件拓展                                   |
| (隐式)链接分配 | 除文件的最后一个盘块之外，每个盘块中都存在指向下个盘块的指针 | 起始块号、结束块号                                           | 可解决碎片问题，外存利用率高，文件拓展方便                   | 只能顺序访问，不能随机访问                                   |
| (显式)链接分配 | 建立一张文件分配表(FAT)，显式记录盘块的先后关系(开机后FAT常驻内存) | 起始块号                                                     | 除了拥有隐式链接的优点外，还可以通过查内存中的FAT实现随机访问 | FAT需要占用一定的存储空间                                    |
| 索引分配       | 为文件数据库建立索引表。若文件太大，可采用链接方案、多层索引、混合索引 | 链接方案记录的是第一个索引块的块号，多层/混合索引记录的是顶级索引块的块号 | 支持随机访问，易于实现文件的拓展                             | 索引表需要占用空间。访问数据块前需要先读入索引块。若采用链接方案，查找索引块时可能需要多次读磁盘操作 |

------

### 文件存储空间管理



#### 存储空间的划分与初始化

为磁盘分区(C盘、D盘等)

存储空间的划分：将物理磁盘划分为一个个文件卷(逻辑卷、逻辑盘)

存储空间初始化：将各个文件卷划分为目录区、文件区

- 目录区

  存放文件目录信息(FCB)、用于磁盘存储空间管理的信息

- 文件区

  普通文件数据

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnnp40ed7ej30ua0nw1hw.jpg" alt="WeChata5a573750b132cbc9cb07670bffc692b.png" style="zoom:33%;" />





#### 存储空间的管理方法

##### 空闲表法

![WeChate0f67aafb1788d9d8b2b4a3880e87130.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnpdokwlrj31hg0oiu0x.jpg)

本分配方法适用于**连续分配方式**



##### 空闲链表法

![WeChat07ae292b50f550bc4d99c6d3290624c7.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnph2bwqij31ey0m0npd.jpg)

###### 空闲盘块链

以盘块为单位组成一条空闲链

操作系统保存着**链头、链尾指针**。

如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。

适用于离散分配



###### 空闲盘区链

以盘区为单位组成一条空闲链

空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针

操作系统保存**链头、链尾**指针

适用于**离散分配、连续分配**。效率更高。



##### 位示图法

![WeChatff5a70998b441a8c478d9c7041a71700.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnrvyfzlhj31hy0p6b2a.jpg)

一般位号用字(16 bits )表示。 这样一个字可以表示16个磁块的状态。

**连续分配、离散分配**都适用



##### 成组链接法

空闲表法、空闲链表法不适用于大型系统，因为空闲表或空闲链表可能过大。UNIX系统采用了**成组链接法**对磁盘空闲块进行管理。



**文件卷的目录区**中专门用一个磁盘块作为“超级块”，**当系统启动时需要将超级块读入内存**。并且要保持内存与外存中的超级块数据一致。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnns45ue37j30ls0gm10v.jpg" alt="WeChat7d3744517a05dff3b1c0f7753085aba4.png" style="zoom:33%;" />

![WeChata95f97913f04618634ed45804f943d11.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnslyanbpj31kc0smnpd.jpg)



------

### 文件的基本操作

#### create系统调用



需要提供参数

1. 所需外存空间大小
2. 文件存放路径
3. 文件名



系统处理create系统调用，主要做了两件事：

1. **在外存中找到文件所需的空间**(空闲链表法、位示图、成组链接法等管理策略)
2. 根据目录存放路径信息找到该目录对应的目录文件，在**目录中创建该文件对应的目录项(文件名、外存地址等)**。



#### delete系统调用

提供参数

1. 文件存放路径
2. 文件名



系统处理delete系统调用，主要做了几件事：

1. 根据文件存放路径找到对应的目录文件，**从目录中找到文件名对应的目录项**。
2. 找到外存位置、文件大小等信息，**回收文件占用的磁盘块**。
3. 从**目录表中删除文件对应的目录项**。



#### open系统调用

提供参数

1. 文件存放路径
2. 文件名
3. 要对文件的操作类型(r, rw等)



系统处理open系统调用，主要做了几件事：

1. 根据路径找到目录文件，**从目录找到文件名对应的目录项**，并检查该用户是否有操作权。
2. **将目录项复制到内存中的“打开文件表”中**。并将对应表目的编号返回给用户。**用户使用打开文件表的编号来指明要操作的文件**。

<img src="http://ww1.sinaimg.cn/large/008aPpVGgy1gnntkhmopfj310s0s61kx.jpg" alt="WeChat79316cc924b95544abca818685b60735.png" style="zoom:33%;" />



![WeChat14bb04cbcb56abe7cf31137dfd67caeb.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnntmmgfnvj31eq0o27wi.jpg)



注意：**打开文件不会把文件读入内存！！！**

只是把**目录项信息分别复制到进程和系统的打开文件表**中。



#### close系统调用

系统处理close系统调用，主要做了几件事：

1. 将进程的打开文件表相应表项删除
2. 回收分配给该文件的内存空间等资源
3. 系统打开文件表的打开计数器count减1，若count=0，则删除对应表项



#### read系统调用

系统处理read系统调用，主要做了几件事：

需要指明哪个文件。还需要指明读入多少数据、读入数据放在内存什么位置。

操作系统会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。



#### write系统调用

指明时哪个文件。会需要指明写回多少数据、写回外存的数据存放位置。



------

### 文件共享

#### 基于索引结点的共享方式(硬链接)

![WeChat84d30b183e6b5a71ba682a8ac6c120b5.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnwwwprnxj31ds0dowwx.jpg)

删除文件时，只有索引结点count=0，才会删除文件。否则删除对应用户的文件目录项



#### 基于符号链的共享方式(软链接)

![WeChatd2e1530b14c0f6dd56176942026a5818.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnx0corhqj31ec0mib29.jpg)

软链接实际上文件时Link类型文件，存放了另一个文件的路径，类似于windows里面的“快捷方式”。



------

### 文件保护

#### 口令保护

为文件设置一个“口令”(如：abc123456)，用户请求访问该文件时需要提供口令。

口令一般**存放在文件对应的FCB或索引结点**中。

优点：保持口令的空间开销不多，验证口令的时间开销也小。

缺点：口令存放在系统内部，不安全



#### 加密保护

使用某个密码对文件进行加密

例如：异或加密

假设密码“01001“

![WeChate9f9434b0df8900b44d4cf3de5eff114.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnxajkwwvj31e20dq4ih.jpg)

优点：保密性强，不需要在系统中存储密码

缺点：时间开销大



#### 访问控制

在每个文件的FCB(或索引结点)中增加一个**访问控制表**(Access-Control List,ACL)，表中记录了各个用户可以对该文件进行哪些操作。



精简访问列表：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。

分组： 系统管理员、文件主、文件主的伙伴、其他用户



### 文件系统的层次结构

![WeChatf26e97d52087637c6f9f5056b66f287f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gnnxjplnhij31lo0suqv7.jpg)



假设某用户请求删除文件“D:/工作目录/学生信息.xlsx”的最后100条记录。

1. 用户通过操作系统提供的接口发出上述请求——**用户接口**
2. 由于用户提供的是文件存放路径，因此操作系统一层层查找目录，找到对应的目录项——**文件目录系统**
3. 不同用户对文件有不同操作权限，需检查用户是否有访问权限——**存取控制模块**
4. 验证了权限后，需要把用户提供的“记录号”转变为对应的逻辑地址——**逻辑文件系统与文件信息缓冲区**
5. 知道了目标记录对应的逻辑地址后，需要转换成实际的物理地址——**物理文件系统**
6. 要删除这条记录，必定要对磁盘设备发出请求——**设备管理程序模块**
7. 删除这些记录后，会有一些盘块空闲，要将空闲盘块回收——**辅助分配模块**



