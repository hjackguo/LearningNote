# 3.1 BIOS

![WeChat39e55d73e76539b65e147fe45cbbd38f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp3f2nbm3ij31t80y01kz.jpg)

> 启动时执行

CS:IP = 0xf000:fff0

(CS:代码寄存器   IP指令指针寄存器)

启动时系统处于**实模式**

PC = 16*CS+IP

CS:IP 是16位寄存器

20位地址空间：1 MB  (*16相当于左移4位)

> BIOS启动固件存储

- 基本输入输出程序
- 系统设置信息
- 开机后自检程序
- 系统自启动程序等

> 加载程序的内存地址空间

BIOS主要执行：

- 将加载程序从磁盘的引导扇区(512字节)加载到0x7c00.
- 跳转到CS:IP = 0000:7c00

加载程序：

- 将操作系统的代码和数据从硬盘加载到内存中
- 跳转到操作系统的起始地址

> 为什么不把加载操作系统的代码写在BIOS上？

因为操作系统存在于磁盘，磁盘上有文件系统，文件系统是多种多样的，BIOS不可能加上所有认识的文件系统格式，所以应该交给对应的加载程序来完成。

![WeChat8e6f6e6f1d1a7aa7acd6caa8cf91129a.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp3ffqyvaej323k15ce85.jpg)

> BIOS系统调用

- BIOS以中断调用的方式提供了基本的I/O功能
  - INT 10h: 字符显示
  - INT 13h: 磁盘扇区读写
  - INT 15h: 检测内存大小
  - INT 16h: 键盘输入
- 只能在x86的**实模式**下访问

# 3.2 系统启动流程

![WeChatc45da33ed103080fc9519bf3596ea3a5.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp3flbkj0lj32580u4b2b.jpg)

> CPU初始化

- CPU加电稳定后从0XFFFF0读第一条指令
  - CS:IP = 0xf000:fff0
  - 第一条指令是跳转指令
- CPU初始化状态为16位实模式
  - CS:IP是16位寄存器
  - 指令指针PC = 16*CS+IP 
  - 最大地址空间是1MB

> BIOS初始化过程

- 硬件自检POST
- 检测系统中内存和显卡等关键部件的存在和工作状态
- 查找并执行显卡等接口卡BIOS，进行设备初始化
- 执行系统BIOS，进行系统检测
  - 检测和配置系统中安装的即插即用设备
- 更新CMOS中的扩展系统配置数据ESCD
- 按指定启动顺序从软盘、硬盘或光驱启动

> 主引导记录MBR格式

![WeChat41845e2dc5d5248a0662c79b16e03aab.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp3g0reg48j326k1447wk.jpg)

- 启动代码：446字节
  - 检查分区表正确性
  - 加载并跳转到磁盘上的引导程序
- 硬盘分区表：64字节
  - 描述分区状态和位置
  - 每个分区描述信息占据16字节
- 结束标志字：2字节(55AA)
  - 主引导记录的有效标志

> 分区引导扇区格式

![WeChatf7010ba57c866a1d0ab6b39f49d67a7c.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp3g71nd68j31ts0h47wh.jpg)

- 跳转指令：跳转到启动代码
  - 与平台相关代码
- 文件卷头：文件系统描述信息
- 启动代码：跳转到加载程序
- 结束标志：55AA

> 加载程序(bootloader)

![WeChatea000b80bcc97cbe023b4d12474e8711.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp3g9ca36oj325c13cnpf.jpg)

- 加载程序

  从文件系统中读取启动配置信息

- 启动菜单

  可选的操作系统内核列表和加载参数

- 操作系统内核

  依据配置加载指定内核并跳转到内核执行

> 系统启动规范

$$

$$

- BIOS
  - 固化到计算机主板上的程序
  - 包括系统设置、自检程序和系统自启动程序
  - BIOS-MBR、BIOS-GPT、 PXE
- UEFI
  - 接口标准
  - 在所有平台上一致的操作系统启动服务

# 3.3 中断、异常和系统调用比较

> 为什么需要中断、异常和系统调用

- 在计算机运行中，内核是被信任的第三方
- 只有内核可以执行特权指令
- 方便应用程序

> 中断和异常希望解决的问题

- 当外设连接计算机时，会出现什么现象？
- 当应用程序处理意想不到的行为时，会出现什么现象？

> 系统调用希望解决的问题

- 用户应用程序是如何得到系统服务？
- 系统调用和功能调用的不同之处是什么？

> 内核的进入与退出

操作系统内核与外界打交道基本通过系统调用、中断、异常。

![WeChat36d4fbc634c91d8e8b9d0ad096e58515.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp3hbez2wdj31fw12cnpe.jpg)

> 定义

- 系统调用(system call)
  - 应用程序**主动**向操作系统发出的服务请求。
- 异常(exception)
  - 非法指令或者其他原因导致当前**指令执行失败**后的处理请求
- 中断(hardware interrupt)
  - 来自**硬件设备**的处理请求

> 比较

- 源头
  - 中断：外设
  - 异常：应用程序意想不到的行为
  - 系统调用：应用程序请求操作提供服务
- 响应方式
  - 中断：异步
  - 异常：同步
  - 系统调用：异步或同步
- 处理机制
  - 中断：持续，对用户应用程序是透明的
  - 异常：杀死或重新执行意想不到的应用程序指令
  - 系统调用：等待和持续

> 中断的处理机制

**硬件处理**

- 在CPU初始化时设置中断使能标志
  - 依据内部或外部事件设置中断标志
  - 依据中断向量调用相应中断服务例程

**软件**

- 现场保存(编译器)
- 中断服务处理(服务例程)
- 清除中断标记(服务例程)
- 现场恢复(编译器)

> 中断嵌套

- 硬件中断服务例程可被打断
  - 不同硬件中断源可能硬件中断处理时出现
  - 硬件中断服务例程中需要临时禁止中断请求
  - 中断请求会保持到CPU做出响应
- 异常服务例程可被打断
  - 异常服务例程执行时可能出现硬件中断
- 异常服务例程可嵌套
  - 异常服务例程可能出现缺页

# 3.4 系统调用

![WeChat98f22e75650f12248276df4a7168caf7.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp3jkdduofj3144190e82.jpg)

> 系统调用

- 操作系统服务的编程接口
- 通常由高级语言编写(C或者C++)
- 程序访问通常是通过高层次的API接口而不是直接进行系统调用
- 三种最常用的应用程序编程接口(API)
  - Win32 API用于Windows
  - POSIX API用于POSIX-based systems (包括UNIX，LINUX，Mac OS X的所有版本)
  - Java API用于JAVA虚拟机(JVM)

> 系统调用的实现

- 每个系统调用都对应一个系统调用号
  - 系统调用接口根据系统调用号来维护表的索引
- 系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果
- 用户不需要知道系统调用的实现
  - 需要设置调用参数和获取返回结果
  - 操作系统接口的细节大部分都隐藏在应用程序接口后
  - 通过运行程序支持的库来管理

> 函数调用和系统调用的不同处

- 系统调用
  - INT和IRET指令用于系统调用
    - 系统调用时，**堆栈切换和特权级的切换**
- 函数调用
  - CALL和RET用于常规调用
    - 常规调用时**没有堆栈切换**

> 中断、异常和系统调用的开销

- 超过函数调用
- 中断、异常和系统调用
  - 引导机制
  - 建立内核堆栈
  - 验证参数
  - 内核态映射到用户态的地址空间
    - 更新页面映射权限
  - 内核态独立地址空间
    - TLB

# 3.5 系统调用示例

> ucore系统调用read(fd, buffer, length)的实现

1. kern/trap/trapentry.S: alltraps()

2. kern/trap/trap.c: trap()

   tf -> trapno == T_SYSCALL

3. kern/syscall/syscall.c: syscall()

   tf -> tf_regs.reg_eax == SYS_read

4. kern/syscall/syscall.c: sys_read()

   从tf->sp获取fd,buf,length

5. kern/fs/sysfile.c: sysfile_read()

   读取文件

6. kern/trap/trapentry.S: trapret()



