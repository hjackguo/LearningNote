# 9.1 页面置换算法的概念

- 功能
  - 当出现缺页异常，需调入新页面而内存已满时，置换算法**选择被置换的物理页面**
- 设计目标
  - 尽可能**减少页面的调入调出次数**
  - 把未来不再访问或短期内不访问的页面调出
- 页面锁定(frame locking)
  - 描述必须常驻内存的逻辑页面
  - 操作系统的关键部分
  - 要求响应速度的代码和数据
  - 页表中锁定标志位(lock bit)

> 页面置换算法分类

- 局部页面置换算法
  - 置换页面的选择访问仅限于当前进程占用的物理页面内
  - 最优算法、先进先出算法、最近最久未使用算法
  - 时钟算法、最不常用算法
- 全局页面置换算法
  - 置换页面的选择范围时所有可换出的物理页面
  - 工作集算法、缺页率算法

# 局部置换算法

## 9.2 最优算法、先进先出算法和最近最久未使用算法

### 最优页面置换算法(OPT,optimal)

- 基本思路
  - 置换在未来最长时间不访问的页面
- 算法实现
  - 缺页时，计算内存中每个逻辑页面的下一次访问时间
  - 选择未来最长时间不访问的页面
- 算法特征
  - 缺页最少，是理想情况
  - 实际系统中**无法实现**
  - 无法预知每个页面在下次访问前的等待时间
  - 最为置换算法的性能评价依据
    - 在模拟器上运行某个程序，并记录每一次的页面访问情况
    - 第二遍运行时使用最优算法

![WeChat0127e3ff50508df0e0ed83a017a551f9.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7dcob0nmj31gg0q8kjm.jpg)



### 先进先出算法(First-In First-Out, FIFO)

- 思路
  - 选择**在内存驻留时间最长**的页面进行置换
- 实现
  - 维护一个记录所有位于内存中的逻辑页面链表
  - 链表元素**按驻留内存的时间排序**，链首最长，链尾最短
  - 出现缺页时，选择链首页面进行置换，新页面加到链尾
- 特征
  - 实现简单
  - 性能较差，调出的页面可能时经常访问的
  - 进程分配物理页面数增加时，缺页并不一定减少(**Belady现象**)
  - 很少单独使用

![WeChat4703c77a9afbb9ed8df889a328b1609f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7dmn6fsgj31gw0kshdu.jpg)



### 最近最久未使用算法 (Least Recently Used, LRU)

- 思路
  - 选择**最长时间没有被引用**的页面进行置换
  - 如某些页面长时间未被访问，则它们在将来还可能会长时间不会访问
- 实现
  - 缺页时，计算内存中每个逻辑页面的**上一次**访问时间
  - 选择**上一次使用到当前时间最长的页面**
- 特征
  - 最优置换算法的一种近似

![WeChat90e9f1a09741afa930b3274fc6993106.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7dvspgr2j31g40qgu0y.jpg)



> LRU算法的可能实现方法

- 页面链表
  - 系统维护一个按最近一次访问时间排序的页面链表
    - 链表首节点是最近刚刚使用过的页面
    - 链表尾节点是最久未使用的页面
  - 访问内存时，找到相应页面，并把它移到链表之首
  - 缺页时，置换链表尾节点的页面
- 活动页面栈
  - 访问页面时，将此页号压入栈顶，并栈内相同的页号抽出
  - 缺页时，置换栈底的页面
- 特征
  - 开销比较大

> 用栈实现LRU算法

![WeChat23d333115c845289fa1e60387fb1e83d.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7e7oj4n1j31go0usqv7.jpg)



## 9.3 时钟置换算法和最不常用算法

### 时钟置换算法(Clock)

- 思路
  - 仅对页面的访问情况进行大致统计
- 数据结构
  - 在页表项中增加**访问位**，描述页面在过去一段时间内的访问情况
  - 各页面组织成**环形链表**
  - **指针**指向最先调入的页面
- 算法
  - 访问页面时，在页表项纪录页面访问情况
  - 缺页时，从指针处开始顺序查找未被访问的页面进行置换
- 特征
  - 时钟算法是LRU和FIFO的折中

> 时钟置换算法的实现

- 页面装入内存时，访问位初始化位0
- 访问页面(读/写)时，访问位置1
- 缺页时，从指针当前位置顺序检查环形链表
  - 访问位为0，则置换该页
  - 访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面



> 时钟页面置换示例

![WeChat8d9b63db54ba279e3a1276ddb77af8a7.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7euv56u1j31es0vgu0x.jpg)

![WeChat6db20b542baeae451e685dee93d77226.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7exuvmqjj31qs0uwnpf.jpg)



> 改进的Clock算法

- 思路
  - 减少修改页的缺页处理开销
- 算法
  - 在页面中增加修改位，并在访问时进行相应修改
  - 缺页时，修改页面标志位，以跳过有修改的页面



![WeChate4adc2a84fadc3a7eff31b6d6865a4ca.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7f1zj6fej31fg0l8x6p.jpg)



![image-20210404014326616](/Users/guohuanjie/Library/Application Support/typora-user-images/image-20210404014326616.png)



### 最不常用算法( Least Frequently Used LFU)

- 思路
  - 缺页时，置换访问次数最少的页面
- 实现
  - 每个页面设置一个访问计数
  - 访问页面时，访问计数加1
  - 缺页时，置换计数最小的页面
- 特征
  - 算法开销大
  - 开始时频繁使用，但以后不使用的页面很难置换
    - 解决方法：计数定期右移 (根据时间损耗)
- LRU和LFU的区别
  - LRU关注多久未访问，时间越短越好
  - LFU关注访问次数，次数越多越好

> LFU算法示例

![WeChatfb1552bed9c93888cd62bb5fa0ddddfa.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7fcoj06pj31gg0l0x6q.jpg)



## 9.4 Belady现象和局部置换算法比较

### Belady现象

- 现象
  - 采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象
- 原因
  - FIFO算法的置换特征与进程访问内存的动态特征矛盾
  - 被它置换出去的页面并不一定是进程近期不会访问的
- 思考
  - 哪些置换算法没有Belady现象？

> FIFO算法有Belady现象

![WeChat98b2e9fb57e68b386945e8da412386ae.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7giys39nj31ug0x8npf.jpg)

![WeChat44efb2d4deb17d9863860a4942e77617.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7gjvahxqj31i00u8kjn.jpg)

**LRU算法没有Belady现象(证明)**

**时钟/改进的时钟有无Belady现象**



### LRU、FIFO和Clock的比较

- LRU算法和FIFO算法本质上都是先进先出的思路
  - LRU依据页面的最近访问时间排序
  - LRU需要动态地调整顺序
  - FIFO依据页面进入内存的时间排序
  - FIFO的页面进入时间是固定不变的
- LRU可退化成FIFO
  - 如页面进入内存后没有被访问，最近访问时间与进入内存的时间相同
  - 例如：给进程分配3个物理页面，逻辑页面的访问顺序为1、2、3、4、5、6、1、2、3...
- LRU算法性能较好，但系统开销大
- FIFO算法系统开销小，会发生Belady现象
- Clock算法是它们的折中
  - 页面访问时，不动态调整页面在链表的顺序，仅做标记(改页表项)
  - 缺页时，通过时针找到替换项
- 对于未被访问的页面，Clock和LRU算法的表现一样好
- 对于被访问过的页面，Clock算法不能记录准确访问顺序，而LRU算法可以



# 全局置换算法

## 9.5 工作集置换算法

> 局部置换算法没有考虑进程访存差异

FIFO页面置换算法

物理页面数：3 			缺页次数：9

![WeChat7832738ef1a9034596e3bffcc2f53397.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7yxe8t4zj31gs0dwx6p.jpg)

物理页面数： 4 		 缺页次数：1

![WeChat94d58f7b073ae8771bbecb80cd5934a0.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7yy75hzhj31go0esqv5.jpg)



> 全局置换算法

- 思路
  - 全局置换算法为进程分配**可变数目**的物理页面
- 全局置换算法要解决的问题
  - 进程在不同阶段的内存需求是变化的
  - 分配给进程的内存也需要在不同阶段有所变化
  - 全局置换算法需要确定分配给进程的物理页面数



> CPU利用率与并发进程数的关系

![WeChat27d9a6870573e6d3fb02bdc8bd3d9e8a.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7z5pnk3hj31dk0mob29.jpg)

- CPU利用率与并发进程数存在相互促进和制约的关系
  - 进程数少时，提高并发进程数，可提高CPU利用率
  - 并发进程导致内存访问增加
  - 并发进程的内存访问会降低访存的局部性特征
  - 局部性特征的下降会导致缺页率上升和CPU利用率下降



> 工作集

一个进程当前正在使用的逻辑页面集合，可表示为二元函数 W(t, delta)

- t是当前的执行时刻
- delta称为工作集窗口(working-set window), 即一个定长的页面访问时间窗口
- W(t, delta) 是指在当前时刻t前的delta时间窗口中的所有访问页面所组成的集合
- |W(t,delta)|指工作集的大小，即页面数目

![WeChat71ebec45abcaf219706e555b87746878.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7zbrj1umj315k0q4hdt.jpg)



> 工作集的变化

![WeChat81b52f7fdc7ca836196baf1f83141ca4.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp7zdlh0yjj314g0kwe81.jpg)

- 进程开始执行后，随着访问新页面逐步建立较稳定的工作集
- 当内存访问的局部性区域的位置**大致稳定**时，工作集大小也大致稳定
- 局部性区域的位置改变时，工作集**快速扩张和收缩**过渡到下一个稳定值



> 常驻集

在当前时刻，进程实际驻留在内存当中的页面集合

- 工作集与常驻集的关系
  - 工作集是进程在运行过程中固有的性质
  - 常驻集取决于系统分配给进程的物理页面数目和页面置换算法
- 缺页率与常驻集的关系
  - 常驻集 ‘包含’ 工作集时，缺页较少
  - 工作集发生剧烈变动(过渡)时，缺页较多
  - 进程常驻集大小达到一定数目后，缺页率也不会明显下降

> 工作集置换算法

- 思路
  - 换出不在工作集中的页面
- 窗口大小n
  - 当前时刻前n个内存访问的页引用时工作集，n被称为窗口大小
- 实现方法
  - 访存链表：维护窗口内的访存页面链表
  - 访存时，换出不在工作集的页面；更新访存链表
  - 缺页时，换入页面，更新访存链表

![WeChat8e3b3fe274459d45eb10ab168985f8b1.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp8046totfj31j80n8kjm.jpg)



## 9.6 缺页率置换算法

> 缺页率(page fault rate)

缺页次数/内存访问次数 或 缺页平均实际时间间隔的倒数

- 影响缺页率的因素
  - 页面置换算法
  - 分配给进程的物理页面数目
  - 页面大小
  - 程序的编写方法



> 缺页率置换算法 (PFF, Page-Fault-Frequency)

![WeChateafa1e4be93bf84b928c99191acfbf9c.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp80vpowbzj30y40jck9a.jpg)

通过调节常驻集大小，使每个进程的缺页率保持在一个合理范围内

- 若进程缺页率过高，则增加常驻集以分配更多的物理页面
- 若进程缺页率多低，则减少常驻集以减少它的物理页面数量



> 缺页率置换算法的实现

- 访存时，设置引用位标志
- 缺页时，计算从上次缺页时间t_last到现在时间t_current的时间间隔
  - 如果t_current - t_last > T, 则置换所有在[t_last,t_current]时间内没有被引用的页
  - 如果t_current - t_last <= T, 则增加缺失页到常驻集中

![WeChatcd6d59f9df3da6e9cadb2127f845e231.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp81jrgjbqj31jc0rgu0y.jpg)



## 9.7 抖动和负载控制

> 抖动问题(thrashing)

- 抖动
  - 进程物理页面太少，不能包含工作集
  - 造成大量缺页，频繁置换
  - 进程运行速度变慢
- 产生抖动的原因
  - 随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升
- 操作系统需在并发水平和缺页率之间达到一个平衡
  - 选择一个适当的进程数目和进程需要的物理页面数

> 负载控制

- 通过调节并发进程数(MPL)来进行系统负载控制
  - WSi = 内存的大小
  - 平均缺页时间间隔(MTBF) = 缺页异常处理时间(PFST)

![WeChat2c6644fe8cb6e5f2e0a615ebcf6db48f.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp821qswquj318k0jo7wh.jpg)









