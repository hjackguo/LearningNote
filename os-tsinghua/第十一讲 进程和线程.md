# 11.1 进程的概念

> 进程的定义

进程是指一个具有一定**独立功能**的程序在一个**数据集合**上的一次**动态执行**过程

> 进程的组成

- 代码
- 数据
- 状态寄存器
  - CPU状态CR0、指令指针IP
- 通用寄存器
  - AX、BX、CX
- 进程占用系统资源
  - 打开文件、已分配内存

> 进程的特点

- 动态性
  - 可动态地创建、结束进程
- 并发性
  - 进程可以被独立调度并占用处理机运行
- 独立性
  - 不同进程的工作不互相影响
- 制约性
  - 因访问共享数据/资源或进程间同步而产生制约

![WeChat032634a23ff730892401dc5895cbc74a.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp99x9vpkij31og0l8kjl.jpg)



> 进程与程序的联系

- 进程是操作系统处于执行状态程序的抽象
  - 程序 = 文件(静态的可执行文件)
  - 进程 = 执行中的程序 = 程序 + 执行状态
- 同一个程序的多次执行过程对应为不同进程
  - 如命令 “ls” 的多次执行对应多个进程
- 进程执行需要的资源
  - 内存：保护代码和数据
  - CPU：执行指令

> 进程与程序的区别

- 进程是动态的，程序是静态的
  - 程序是有序代码的集合
  - 进程是程序的执行，进程有核心态/用户态
- 进程是暂时的，程序是永久的
  - 进程是一个状态变化的过程
  - 程序可长久保存
- 进程与程序的组成不同
  - 进程的组成包括程序、数据和进程控制块



# 11.2 进程控制块 (PCB)

PCB, Process Control Block

操作系统管理控制进程运行所用的信息集合

- 操作系统用PCB来描述进程的基本情况以及运行变化的过程
- PCB是进程存在的唯一标志
  - 每个进程都在操作系统中有一个对应的PCB

> 进程控制块的使用

- 进程创建
  - 生成该进程的PCB
- 进程终止
  - 回收它的PCB
- 进程的组织管理
  - 通过对PCB的组织管理来实现

> 进程控制块

- 进程标识信息
- 处理机现场保存
- 进程控制信息

![WeChat5a28d209fa253e4b63658d1af1f8d425.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9aj1315uj31h00y0kjm.jpg)

> 进程控制信息

- 调度和状态信息
  - 调度进程和处理机使用情况
- 进程间通信信息
  - 进程间通信相关的各种标识
- 存储管理信息
  - 指向进程映像存储空间数据结构
- 进程所用资源
  - 进程使用的系统资源，如打开文件等
- 有关数据结构连接信息
  - 与PCB相关的进程队列

> 进程控制块的组织

- 链表

  同一状态的进程其PCB成一链表，多个状态对应多个不同的链表

  - 各状态的进程形成不同的链表：就绪链表、阻塞链表

- 索引表

  同一状态的进程归入一个索引表(由索引指向PCB)，多个状态对应多个不同的索引表

  - 各状态的进行形成不同的索引表：就绪索引表、阻塞索引表

  ![WeChat3474229507855450be21cecf773cfc1e.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9asszf47j31r40fkb29.jpg)



# 11.3 进程状态

> 进程的生命周期划分

- 进程创建
- 进程执行
- 进程阻塞
- 进程抢占
- 进程唤醒
- 进程结束

![WeChat98eb8e1d414d50f95f521bb1cec6bc38.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9bn2do5qj30ws0rw7wh.jpg)





> 进程创建

引起进程创建的情况

- 系统初始化时
- 用户请求创建一个新进程
- 正在运行的进程执行了创建进程的系统调用



> 进程执行

就绪态 -> 运行态



内核选择一个就绪的进程，让它占用处理机并执行



> 进程阻塞

运行态 - > 阻塞态



- 进程进入等待(阻塞)的情况：
  - 请求并等待系统服务，无法马上完成
  - 启动某种操作，无法马上完成
  - 需要的数据没有到达
- 只有进程自身才能知道何时需要等待某种事件的发生



> 进程抢占

运行态 -> 就绪态



- 进程会被抢占的情况：
  - 高优先级进程就绪
  - 进程执行当前时间用完



> 进程唤醒

阻塞态 -> 就绪态



- 唤醒进程的情况
  - 被阻塞进程需要的资源可被满足
  - 被阻塞进程等待的事件到达 
- 进程只能被别的进程或操作系统唤醒



> 进程结束

- 进程结束的情况：
  - 正常退出 (自愿的)
  - 错误退出 (自愿的)
  - 致命错误 (强制性的)
  - 被其他进程所杀 (强制性的)

> 进程切换

![WeChat9b2a487fa4794377ef24afd020aed321.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9czlggqaj3274164hdw.jpg)



# 11.4 三状态进程模型

![WeChat8bf04a154186f14f0188bc886b848e2a.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9d2d27r3j316o0tgb2a.jpg)

- 运行状态(Running)
- 就绪状态(Ready)
- 阻塞状态(又称等待状态Blocked)
- 创建状态(New)
- 退出状态(Exit)



# 11.5 挂起进程模型

> 进程挂起

处于挂起状态的进程映像在磁盘上，目的是减少进程占用内存

![WeChat71bc882826b7affb49efbf6d10fe79df.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9d97232zj31aw0yw4qr.jpg)

- 等待挂起状态(Blocked-suspend)
  - 进程在外存并等待某事件的出现
- 就绪挂起状态(Ready-suspend)
  - 进程在外存，当只要进入内存，即可运行

> 与挂起相关的状态转换

- 挂起(Suspend)：把一个进程从内存转到外存

  - 在内存中的状态转换

    - 等待到等待挂起

      没有进程处于就绪状态或就绪进程要求更多内存资源

    - 就绪到就绪挂起

      当有高优先级阻塞(系统认为会很快就绪的)进程和低优先级的就绪线程

    - 运行到就绪挂起

      对抢占式分时系统，当有高优先级阻塞挂起进程因事件出现而进入就绪挂起

  - 在外存时的状态转换

    - 等待挂起到就绪挂起

      当有等待挂起进程因相关事件出现

- 激活(Activate):把一个进程从外存转到内存

  - 就绪挂起到就绪

    没有就绪线程或挂起就绪线程优先级高于就绪线程

  - 阻塞挂起到阻塞

    当一个进程释放足够内存，并有高优先级等挂挂起进程

> 状态队列

- 由操作系统来维护一组队列，表示系统中所有进程的当前状态
- 不同队列表示不同状态
  - 就绪队列、各种等待队列
- 根据进程状态不同，进程PCB加入相应队列
  - 进程状态变化时，它所在的PCB会从一个队列换到另一个

![WeChat7feef746cbf3b011899f199ec321d506.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9eb5xnumj31pk15w1kz.jpg)



# 11.6 线程的概念

线程是进程的一部分，描述指令流执行状态。它是进程中的**指令执行流**的最小单位，是**CPU调度**的基本单位。

- 进程的资源分配角色

  进程由一组相关资源构成，包括地址空间(代码段、数据段)、打开的文件等各种资源

- 线程的处理机调度角色

  线程描述在进程资源环境中的指令流执行状态



> 为什么不直接多进程实现一个系统？

进程间还需要系统调用绕一圈再执行，开销大



> 进程和线程的关系

![WeChat8fc69e24f56def1acd608853d21bb999.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9oc19iwsj31n00vckjm.jpg)



> 线程 = 进程 - 共享资源

- 线程的优点：
  - 一个进程中可以同时存在多个线程
  - 各个线程之间可以并发地执行
  - 各个线程之间可以共享地址空间和文件等资源
- 线程的缺点：
  - 一个线程崩溃，会导致其所属进程的所有线程崩溃



> 不同操作系统对线程的支持

![WeChat6c637450e8a6d13dca6c971d78d2b582.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9og5jrgmj31f40v0kjm.jpg)



> 线程与进程的比较

- 进程是资源分配的单位，线程是CPU调度单位
- 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈
- 线程具有就绪、等待和运行三种基本状态和状态间的转换关系
- 线程能减少并发执行的时间和空间开销
  - 线程的创建时间比进程短
  - 线程的终止时间比进程短
  - 同一进程内的线程切换时间比进程短
  - 由于同一进程的各线程间共享内存和文件资源，可不通过内核进行直接通信

# 11.7 用户线程

> 线程的三种实现方式

- 用户线程：在用户空间实现

  POSIX Pthreads, Mach C-threads, Solaris threads

- 内核线程：在内核中实现

  Windows , Solaris, Linux

- 轻量级进程：在内核中实现，支持用户线程

  Solaris  (LightWeight Process)



> 用户线程

由一组用户级的线程函数来完成线程的管理，包括线程的创建、终止、同步和调度等

![WeChatbc36e2b184e5d75e246b64a17e0ffac6.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9oqor3r7j31ng0zsx6q.jpg)

> 用户线程的特征

- 不依赖于操作系统的内核
  - 内核不了解用户线程的存在
  - 可用于不支持线程的多进程操作系统
- 在用户空间实现的线程机制
  - 每个进程有私有的线程控制块(TCB)列表
  - TCB由线程库函数维护
- 同一进程内的用户线程切换速度快
  - 无需用户态/内核态切换
- 允许每个进程拥有自己的线程调度算法



> 用户线程的不足

- 线程发起系统调用而阻塞时，则整个进程进入等待
- 不支持基于线程的处理机抢占
  - 除非当前运行线程主动放弃，它所在进程的其他线程无法抢占CPU
  - 只能按进程分配CPU时间
    - 每个多线程进程中，每个线程的时间片较少



# 11.8 内核线程

由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理

![WeChat8dee12bbd9f574a0745ccabaf68c02af.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9p66vu8uj31940ochdt.jpg)

> 内核线程的特征

- 由内核维护PCB和TCB
- 线程执行系统调用而被阻塞不影响其他线程
- 线程的创建、终止和切换开销相对较大
  - 通过系统调用/内核函数，在内核实现
- 以线程为单位进行CPU时间分配
  - 多线程的进程可获得更多CPU时间



> 轻权进程 (LightWeight Process)

内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个轻权进程由一个单独的内核线程来支持。 (Solaris/Linux)

![WeChat1ded07d09ba9424f251d4c4ea4d0d148.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9pcr07oej31o80os4qr.jpg)



> 用户线程与内核线程的对应关系

![WeChat62deeef96ec66594e9b47d8d4297c432.png](http://ww1.sinaimg.cn/large/008aPpVGgy1gp9pduak31j31ws1487wj.jpg)

